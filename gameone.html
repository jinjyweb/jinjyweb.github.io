<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>üåä Sink or Sell</title>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #1a3a52 0%, #2d5a7b 50%, #1a3a52 100%);
  min-height: 100vh;
  padding: 10px;
  color: #fff;
  -webkit-tap-highlight-color: transparent;
}

.game-container {
  max-width: 900px;
  margin: 0 auto;
}

/* Language Toggle */
.lang-toggle {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1001;
  display: flex;
  gap: 5px;
  background: rgba(0,0,0,0.4);
  padding: 5px;
  border-radius: 20px;
}

.lang-btn {
  padding: 6px 12px;
  border: none;
  border-radius: 15px;
  cursor: pointer;
  font-size: 0.85rem;
  font-weight: bold;
  transition: all 0.2s ease;
  background: transparent;
  color: rgba(255,255,255,0.6);
}

.lang-btn.active {
  background: rgba(255,255,255,0.2);
  color: white;
}

.lang-btn:hover {
  background: rgba(255,255,255,0.15);
}

h1 {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 8px;
  text-shadow: 2px 2px 8px rgba(0,0,0,0.4);
  letter-spacing: 2px;
  padding-top: 35px;
}

.subtitle {
  text-align: center;
  font-size: 0.95rem;
  opacity: 0.85;
  margin-bottom: 20px;
  font-style: italic;
}

/* Player Panel */
#player-panel {
  background: rgba(255,255,255,0.1);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 20px;
  border: 1px solid rgba(255,255,255,0.2);
}

.round-display {
  text-align: center;
  font-size: 1.1rem;
  margin-bottom: 10px;
  padding: 8px 20px;
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
  display: inline-block;
  width: 100%;
}

/* Flood Risk Bar */
#flood-risk-container {
  margin-bottom: 15px;
}

.flood-risk-label {
  text-align: center;
  font-size: 0.9rem;
  margin-bottom: 6px;
  font-weight: bold;
}

.flood-risk-bar {
  background: rgba(0,0,0,0.4);
  border-radius: 10px;
  height: 28px;
  position: relative;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.2);
}

.flood-risk-fill {
  height: 100%;
  width: 10%;
  background: linear-gradient(90deg, #4caf50, #ffeb3b, #ff9800, #f44336);
  background-size: 400% 100%;
  border-radius: 8px;
  transition: width 0.5s ease;
}

.flood-risk-markers {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 10px;
  font-size: 0.7rem;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  pointer-events: none;
}

.players-row {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

.player-card {
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  padding: 8px 12px;
  min-width: 70px;
  text-align: center;
  transition: all 0.3s ease;
  border: 3px solid transparent;
  flex: 1;
  max-width: 120px;
}

.player-card.active {
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(255,255,255,0.3);
}

.player-card .name {
  font-weight: bold;
  font-size: 0.85rem;
  margin-bottom: 3px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.player-card .money {
  font-size: 1.1rem;
  font-weight: bold;
}

.player-card .token {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  margin: 0 auto 5px;
  border: 2px solid white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9rem;
}

/* Controls */
.controls {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  margin-bottom: 15px;
}

.btn {
  padding: 10px 12px;
  font-size: 0.85rem;
  font-weight: bold;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  min-height: 44px;
}

.btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
  filter: grayscale(80%);
}

.btn-roll {
  background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
  color: white;
}

.btn-buy {
  background: linear-gradient(135deg, #4ecdc4, #44a08d);
  color: white;
}

.btn-contribute {
  background: linear-gradient(135deg, #a18cd1, #8b7dc9);
  color: white;
}

.btn-end {
  background: linear-gradient(135deg, #667eea, #5a6fd6);
  color: white;
}

.btn-build {
  background: linear-gradient(135deg, #8d6e63, #6d4c41);
  color: white;
}

/* Board - Monopoly Style */
#board {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 4px;
  margin-bottom: 15px;
  width: min(500px, calc(100vw - 20px));
  height: min(500px, calc(100vw - 20px));
  margin-left: auto;
  margin-right: auto;
}

/* Position tiles around the perimeter */
.tile[data-pos="0"] { grid-column: 5; grid-row: 5; } /* Start - bottom right corner */
.tile[data-pos="1"] { grid-column: 4; grid-row: 5; }
.tile[data-pos="2"] { grid-column: 3; grid-row: 5; }
.tile[data-pos="3"] { grid-column: 2; grid-row: 5; }
.tile[data-pos="4"] { grid-column: 1; grid-row: 5; } /* bottom left corner */
.tile[data-pos="5"] { grid-column: 1; grid-row: 4; }
.tile[data-pos="6"] { grid-column: 1; grid-row: 3; }
.tile[data-pos="7"] { grid-column: 1; grid-row: 2; }
.tile[data-pos="8"] { grid-column: 1; grid-row: 1; } /* top left corner */
.tile[data-pos="9"] { grid-column: 2; grid-row: 1; }
.tile[data-pos="10"] { grid-column: 3; grid-row: 1; }
.tile[data-pos="11"] { grid-column: 4; grid-row: 1; }
.tile[data-pos="12"] { grid-column: 5; grid-row: 1; } /* top right corner */
.tile[data-pos="13"] { grid-column: 5; grid-row: 2; }
.tile[data-pos="14"] { grid-column: 5; grid-row: 3; }
.tile[data-pos="15"] { grid-column: 5; grid-row: 4; }

/* Center area - game title */
.board-center {
  grid-column: 2 / 5;
  grid-row: 2 / 5;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.3);
  border-radius: 12px;
  padding: 15px;
  text-align: center;
}

.tile {
  border-radius: 8px;
  padding: 4px;
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  transition: all 0.3s ease;
  border: 3px solid transparent;
  cursor: pointer;
  overflow: hidden;
}

.tile:hover {
  transform: scale(1.02);
}

.tile-number {
  position: absolute;
  top: 2px;
  left: 4px;
  font-weight: bold;
  font-size: 0.7rem;
  opacity: 0.7;
}

.tile-icon {
  text-align: center;
  font-size: 1.5rem;
  margin: 2px 0;
}

.tile-label {
  text-align: center;
  font-size: 0.6rem;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.tile-state {
  text-align: center;
  font-size: 0.7rem;
  opacity: 0.8;
  margin-top: 2px;
}

.tile.property {
  background: linear-gradient(145deg, #81d4fa, #4fc3f7);
  color: #0d47a1;
}

.tile.policy {
  background: linear-gradient(145deg, #a5d6a7, #81c784);
  color: #1b5e20;
}

.tile.storm {
  background: linear-gradient(145deg, #ffe082, #ffb74d);
  color: #e65100;
}

.tile.flood {
  background: linear-gradient(145deg, #ef9a9a, #e57373);
  color: #b71c1c;
}

.tile.start {
  background: linear-gradient(145deg, #fff59d, #fff176);
  color: #f57f17;
}

.tile.flooded {
  opacity: 0.65;
  background-image: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 5px,
    rgba(0,100,200,0.15) 5px,
    rgba(0,100,200,0.15) 10px
  );
}

.tile.sunk {
  background: linear-gradient(145deg, #546e7a, #37474f) !important;
  color: #90a4ae !important;
}

.tile.sunk .tile-icon {
  opacity: 0.5;
}

/* Wall Progress */
.wall-progress {
  display: flex;
  gap: 3px;
  justify-content: center;
  margin-top: 4px;
}

.wall-brick {
  width: 16px;
  height: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 2px;
}

.wall-brick.filled {
  background: #8d6e63;
  box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2);
}

/* Shield indicator */
.shield {
  position: absolute;
  top: 3px;
  right: 5px;
  font-size: 1.2rem;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.15); }
}

/* Players on tiles */
.tile-players {
  position: absolute;
  bottom: 5px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 4px;
}

.player-dot {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.55rem;
}

/* Log */
#log {
  background: rgba(0,0,0,0.4);
  border-radius: 12px;
  padding: 15px;
  max-height: 150px;
  overflow-y: auto;
  font-size: 0.9rem;
  line-height: 1.6;
  border: 1px solid rgba(255,255,255,0.1);
}

#log::-webkit-scrollbar {
  width: 8px;
}

#log::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

#log::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.3);
  border-radius: 4px;
}

.log-entry {
  padding: 4px 0;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.log-entry:last-child {
  border-bottom: none;
}

/* Rules Panel */
.rules-panel {
  background: rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 20px;
  margin-top: 20px;
  border: 1px solid rgba(255,255,255,0.15);
}

.rules-panel h2 {
  text-align: center;
  margin-bottom: 15px;
  font-size: 1.3rem;
}

.rules-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.rule-item {
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 12px;
}

.rule-item h3 {
  font-size: 0.95rem;
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.rule-item p {
  font-size: 0.8rem;
  opacity: 0.85;
  line-height: 1.4;
}

/* Tile selection modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-overlay.active {
  display: flex;
}

.modal {
  background: linear-gradient(135deg, #2d5a7b, #1a3a52);
  border-radius: 16px;
  padding: 25px;
  max-width: 400px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  border: 2px solid rgba(255,255,255,0.2);
}

.modal h3 {
  text-align: center;
  margin-bottom: 15px;
}

.modal-tiles {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 5px;
  margin-bottom: 15px;
  aspect-ratio: 1;
  max-width: 350px;
  margin-left: auto;
  margin-right: auto;
}

/* Position modal tiles around the perimeter like Monopoly board */
.modal-tile[data-pos="0"] { grid-column: 5; grid-row: 5; }
.modal-tile[data-pos="1"] { grid-column: 4; grid-row: 5; }
.modal-tile[data-pos="2"] { grid-column: 3; grid-row: 5; }
.modal-tile[data-pos="3"] { grid-column: 2; grid-row: 5; }
.modal-tile[data-pos="4"] { grid-column: 1; grid-row: 5; }
.modal-tile[data-pos="5"] { grid-column: 1; grid-row: 4; }
.modal-tile[data-pos="6"] { grid-column: 1; grid-row: 3; }
.modal-tile[data-pos="7"] { grid-column: 1; grid-row: 2; }
.modal-tile[data-pos="8"] { grid-column: 1; grid-row: 1; }
.modal-tile[data-pos="9"] { grid-column: 2; grid-row: 1; }
.modal-tile[data-pos="10"] { grid-column: 3; grid-row: 1; }
.modal-tile[data-pos="11"] { grid-column: 4; grid-row: 1; }
.modal-tile[data-pos="12"] { grid-column: 5; grid-row: 1; }
.modal-tile[data-pos="13"] { grid-column: 5; grid-row: 2; }
.modal-tile[data-pos="14"] { grid-column: 5; grid-row: 3; }
.modal-tile[data-pos="15"] { grid-column: 5; grid-row: 4; }

.modal-center {
  grid-column: 2 / 5;
  grid-row: 2 / 5;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  font-size: 0.8rem;
  text-align: center;
  padding: 10px;
}

.modal-tile {
  padding: 5px;
  border-radius: 6px;
  text-align: center;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s ease;
  font-size: 0.7rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 50px;
}

.modal-tile .tile-icon {
  font-size: 1.2rem;
}

.modal-tile:hover:not(.disabled) {
  border-color: white;
  transform: scale(1.05);
}

.modal-tile.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.modal-tile.property { background: #4fc3f7; color: #0d47a1; }
.modal-tile.policy { background: #81c784; color: #1b5e20; }
.modal-tile.storm { background: #ffb74d; color: #e65100; }
.modal-tile.flood { background: #e57373; color: #b71c1c; }
.modal-tile.start { background: #fff176; color: #f57f17; }
.modal-tile.sunk { background: #546e7a; color: #90a4ae; }

.btn-cancel {
  width: 100%;
  padding: 10px;
  background: rgba(255,255,255,0.1);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 8px;
  cursor: pointer;
}

.btn-cancel:hover {
  background: rgba(255,255,255,0.2);
}

/* Setup Modal */
.setup-modal {
  max-width: 500px;
  max-height: 85vh;
  overflow-y: auto;
}

.setup-modal::-webkit-scrollbar {
  width: 8px;
}

.setup-modal::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.setup-modal::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.3);
  border-radius: 4px;
}

/* Player setup list scrollable */
#player-setup {
  max-height: 45vh;
  overflow-y: auto;
  padding-right: 5px;
}

#player-setup::-webkit-scrollbar {
  width: 6px;
}

#player-setup::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 3px;
}

#player-setup::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}

.player-setup-row {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 12px;
  padding: 12px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.player-setup-top {
  display: flex;
  gap: 10px;
  align-items: center;
}

.player-emoji-display {
  width: 50px;
  height: 50px;
  font-size: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.15);
  border: 3px solid rgba(78, 205, 196, 0.4);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.player-emoji-display::after {
  content: '‚úèÔ∏è';
  position: absolute;
  bottom: -5px;
  right: -5px;
  font-size: 0.7rem;
  background: #4ecdc4;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.8;
}

.player-emoji-display:hover {
  background: rgba(78, 205, 196, 0.3);
  transform: scale(1.1);
  border-color: #4ecdc4;
  box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
}

.player-name-input {
  flex: 1;
  padding: 10px 12px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  background: rgba(255,255,255,0.9);
  color: #333;
}

.random-btn {
  width: 44px;
  height: 44px;
  font-size: 1.5rem;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.random-btn:hover {
  transform: scale(1.1) rotate(15deg);
  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

.random-btn:active {
  transform: scale(0.95);
}

.color-picker {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: center;
}

.color-option {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  cursor: pointer;
  border: 3px solid transparent;
  transition: all 0.2s ease;
}

.color-option:hover {
  transform: scale(1.15);
}

.color-option.selected {
  border-color: white;
  box-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* Emoji Picker Modal */
#emoji-picker-modal {
  z-index: 2000;
  background: rgba(0,0,0,0.85);
}

.emoji-picker-modal {
  max-width: 340px;
  width: 90%;
  text-align: center;
  background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
  border: 3px solid rgba(78, 205, 196, 0.6);
  box-shadow: 0 20px 60px rgba(0,0,0,0.6), 0 0 40px rgba(78, 205, 196, 0.3);
  padding: 25px;
  border-radius: 20px;
}

.emoji-picker-title {
  font-size: 1.3rem;
  margin-bottom: 15px;
}

.emoji-picker-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 8px;
  max-height: 250px;
  overflow-y: auto;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 12px;
}

.emoji-option {
  width: 45px;
  height: 45px;
  font-size: 1.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.1);
  border: 2px solid transparent;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.emoji-option:hover {
  background: rgba(255,255,255,0.2);
  transform: scale(1.15);
}

.emoji-option.selected {
  border-color: #4ecdc4;
  background: rgba(78, 205, 196, 0.2);
  box-shadow: 0 0 10px rgba(78, 205, 196, 0.4);
}

.emoji-picker-close {
  margin-top: 15px;
  padding: 10px 30px;
  font-size: 1rem;
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  border: none;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
}

.emoji-picker-close:hover {
  transform: scale(1.05);
}

/* Player Count Selection */
.player-count-section {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
}

.player-count-buttons {
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

.player-count-btn {
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.3);
  background: rgba(0,0,0,0.3);
  color: white;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
}

.player-count-btn:hover {
  transform: scale(1.1);
  border-color: rgba(255,255,255,0.6);
}

.player-count-btn.selected {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border-color: white;
  box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
}

/* Victory Modal */
.victory-modal {
  max-width: 450px;
  text-align: center;
  background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
  border: 3px solid;
  animation: victoryAppear 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.victory-modal.collective {
  border-color: #4caf50;
  box-shadow: 0 0 60px rgba(76, 175, 80, 0.5), 0 0 100px rgba(76, 175, 80, 0.3);
}

.victory-modal.individual {
  border-color: #ffc107;
  box-shadow: 0 0 60px rgba(255, 193, 7, 0.5), 0 0 100px rgba(255, 193, 7, 0.3);
}

.victory-modal.catastrophe {
  border-color: #f44336;
  box-shadow: 0 0 60px rgba(244, 67, 54, 0.5), 0 0 100px rgba(244, 67, 54, 0.3);
}

@keyframes victoryAppear {
  0% { transform: scale(0.3) rotateY(90deg); opacity: 0; }
  50% { transform: scale(1.1) rotateY(-10deg); }
  100% { transform: scale(1) rotateY(0deg); opacity: 1; }
}

.victory-icon {
  font-size: 5rem;
  margin: 10px 0;
  animation: victoryBounce 1s ease-in-out infinite;
}

@keyframes victoryBounce {
  0%, 100% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-15px) scale(1.1); }
}

.victory-title {
  font-size: 2rem;
  font-weight: bold;
  margin: 15px 0;
  text-transform: uppercase;
  letter-spacing: 3px;
}

.victory-modal.collective .victory-title { color: #4caf50; }
.victory-modal.individual .victory-title { color: #ffc107; }
.victory-modal.catastrophe .victory-title { color: #f44336; }

.victory-message {
  font-size: 1.1rem;
  margin: 15px 0;
  line-height: 1.6;
  opacity: 0.9;
}

.victory-players {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin: 20px 0;
}

.victory-player {
  padding: 8px 15px;
  border-radius: 20px;
  font-weight: bold;
  font-size: 0.95rem;
}

.victory-stats {
  background: rgba(0,0,0,0.3);
  padding: 15px;
  border-radius: 10px;
  margin: 15px 0;
  font-size: 0.95rem;
}

.btn-restart {
  padding: 15px 40px;
  font-size: 1.2rem;
  font-weight: bold;
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border: none;
  border-radius: 30px;
  cursor: pointer;
  margin-top: 15px;
  transition: all 0.3s ease;
}

.btn-restart:hover {
  transform: scale(1.05);
  box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5);
}

/* Tile Info Modal */
.tile-info-modal {
  max-width: 380px;
}

.tile-info-header {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 15px;
  padding-bottom: 15px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
}

.tile-info-icon {
  font-size: 3rem;
  width: 70px;
  height: 70px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
}

.tile-info-icon.property { background: #4fc3f7; }
.tile-info-icon.policy { background: #81c784; }
.tile-info-icon.storm { background: #ffb74d; }
.tile-info-icon.flood { background: #e57373; }
.tile-info-icon.start { background: #fff176; }

.tile-info-title {
  flex: 1;
}

.tile-info-title h3 {
  font-size: 1.3rem;
  margin-bottom: 5px;
}

.tile-info-title .tile-type-badge {
  font-size: 0.8rem;
  padding: 3px 10px;
  border-radius: 12px;
  display: inline-block;
}

.tile-type-badge.property { background: rgba(79,195,247,0.3); color: #81d4fa; }
.tile-type-badge.policy { background: rgba(129,199,132,0.3); color: #a5d6a7; }
.tile-type-badge.storm { background: rgba(255,183,77,0.3); color: #ffe082; }
.tile-type-badge.flood { background: rgba(229,115,115,0.3); color: #ef9a9a; }
.tile-type-badge.start { background: rgba(255,241,118,0.3); color: #fff59d; }

.tile-info-rules {
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 15px;
}

.tile-info-rules h4 {
  margin-bottom: 10px;
  font-size: 1rem;
  opacity: 0.9;
}

.tile-info-rules ul {
  list-style: none;
  padding: 0;
}

.tile-info-rules li {
  padding: 6px 0;
  font-size: 0.9rem;
  display: flex;
  align-items: flex-start;
  gap: 8px;
  line-height: 1.4;
}

.tile-info-rules li::before {
  content: '';
  width: 6px;
  height: 6px;
  background: currentColor;
  border-radius: 50%;
  margin-top: 6px;
  flex-shrink: 0;
}

/* Dice animation */
.dice-result {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 999;
  text-align: center;
}

.dice-container {
  perspective: 800px;
  margin: 0 auto;
}

.dice-face-display {
  font-size: 8rem;
  width: 140px;
  height: 140px;
  line-height: 140px;
  background: linear-gradient(145deg, #ffffff, #f0f0f0);
  border-radius: 20px;
  box-shadow: 
    0 10px 40px rgba(0,0,0,0.5),
    0 0 60px rgba(255,255,255,0.3),
    inset 0 2px 10px rgba(255,255,255,0.9),
    inset 0 -2px 10px rgba(0,0,0,0.1);
  margin: 0 auto;
  color: #1a1a2e;
  transition: all 0.1s ease;
}

.dice-result.rolling .dice-face-display {
  animation: diceRoll3D 0.08s ease-in-out infinite;
  box-shadow: 
    0 10px 40px rgba(0,0,0,0.5),
    0 0 80px rgba(255,200,50,0.6),
    inset 0 2px 10px rgba(255,255,255,0.9);
}

.dice-result.bounce .dice-face-display {
  animation: diceBounce 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  box-shadow: 
    0 15px 50px rgba(0,0,0,0.6),
    0 0 100px rgba(100,255,100,0.5),
    inset 0 2px 10px rgba(255,255,255,0.9);
}

.dice-result.final .dice-face-display {
  animation: diceFinal 0.5s ease-out forwards;
}

@keyframes diceRoll3D {
  0% { 
    transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(1);
  }
  25% { 
    transform: rotateX(90deg) rotateY(90deg) rotateZ(45deg) scale(0.95);
  }
  50% { 
    transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg) scale(1.05);
  }
  75% { 
    transform: rotateX(270deg) rotateY(270deg) rotateZ(135deg) scale(0.95);
  }
  100% { 
    transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg) scale(1);
  }
}

@keyframes diceBounce {
  0% { transform: translateY(-80px) rotateZ(-20deg) scale(0.6); opacity: 0.5; }
  40% { transform: translateY(10px) rotateZ(5deg) scale(1.15); opacity: 1; }
  60% { transform: translateY(-8px) rotateZ(-2deg) scale(1.05); }
  80% { transform: translateY(4px) rotateZ(1deg) scale(1.02); }
  100% { transform: translateY(0) rotateZ(0deg) scale(1); }
}

@keyframes diceFinal {
  0% { transform: scale(1) rotateZ(0deg); opacity: 1; }
  50% { transform: scale(1.2) rotateZ(10deg); opacity: 1; }
  100% { transform: scale(0.5) rotateZ(-20deg); opacity: 0; }
}

.dice-player-name {
  font-size: 1.4rem;
  text-align: center;
  margin-bottom: 15px;
  font-weight: bold;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.dice-result-number {
  font-size: 2rem;
  margin-top: 15px;
  font-weight: bold;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  opacity: 0;
}

.dice-result.bounce .dice-result-number,
.dice-result.final .dice-result-number {
  animation: fadeInUp 0.3s ease-out 0.3s forwards;
}

@keyframes fadeInUp {
  0% { opacity: 0; transform: translateY(10px); }
  100% { opacity: 1; transform: translateY(0); }

#climate-container {
  background: rgba(0,0,0,0.3);
  padding: 10px 15px;
  border-radius: 10px;
  margin-bottom: 15px;
}

.climate-label {
  font-size: 0.9rem;
  margin-bottom: 8px;
  text-align: center;
}

.climate-bar {
  height: 20px;
  background: #333;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.climate-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #f44336, #ff9800);
  border-radius: 10px;
  transition: all 0.5s ease;
}

.climate-status {
  font-size: 0.8rem;
  text-align: center;
  margin-top: 5px;
  font-style: italic;
}

.climate-status.stable {
  color: #4caf50;
}

.climate-status.improving {
  color: #8bc34a;
}

.climate-status.warning {
  color: #ff9800;
}

.climate-status.danger {
  color: #f44336;
}

/* Mobile Responsive */
@media (max-width: 600px) {
  body { padding: 2px; }
  
  .game-container { max-width: 100%; }
  
  h1 { font-size: 1.2rem; padding-top: 35px; margin-bottom: 2px; }
  
  .subtitle { font-size: 0.7rem; margin-bottom: 5px; }
  
  .lang-toggle {
    top: 3px;
    right: 3px;
    padding: 2px;
  }
  .lang-btn { padding: 3px 6px; font-size: 0.7rem; }
  
  #player-panel { padding: 6px; margin-bottom: 5px; border-radius: 10px; }
  
  .round-display { font-size: 0.75rem; padding: 4px 10px; margin-bottom: 5px; }
  
  .players-row { gap: 3px; }
  .player-card { 
    padding: 4px 5px; 
    min-width: 40px;
    max-width: 70px;
    border-radius: 5px;
    border-width: 2px;
  }
  .player-card .name { font-size: 0.6rem; }
  .player-card .money { font-size: 0.75rem; }
  .player-card .token { width: 16px; height: 16px; margin-bottom: 2px; border-width: 1px; font-size: 0.6rem; }
  
  /* Setup mobile */
  .player-setup-row { padding: 10px; }
  .player-setup-top { gap: 8px; }
  .player-emoji-display { width: 40px; height: 40px; font-size: 1.5rem; }
  .player-name-input { padding: 8px 10px; font-size: 0.9rem; }
  .random-btn { width: 38px; height: 38px; font-size: 1.2rem; }
  .color-option { width: 22px; height: 22px; }
  
  /* Emoji picker mobile */
  .emoji-picker-grid { grid-template-columns: repeat(5, 1fr); gap: 6px; }
  .emoji-option { width: 40px; height: 40px; font-size: 1.5rem; }
  
  .controls { gap: 3px; margin-bottom: 5px; }
  .btn { 
    padding: 5px 3px; 
    font-size: 0.65rem; 
    border-radius: 5px;
    min-height: 32px;
    gap: 2px;
  }
  
  /* Board - CRITICAL for mobile portrait */
  #board { 
    width: calc(100vw - 10px);
    height: calc(100vw - 10px);
    max-width: 320px;
    max-height: 320px;
    gap: 2px;
    margin-bottom: 5px;
  }
  .tile { 
    padding: 1px;
    border-radius: 4px;
    border-width: 2px;
  }
  .board-center {
    padding: 3px;
    border-radius: 6px;
  }
  .board-center > div:first-child { font-size: 1rem; }
  .board-center > div:nth-child(2) { font-size: 0.6rem; }
  .board-center > div:nth-child(3) { display: none; }
  .tile-icon { font-size: 0.9rem; margin: 0; }
  .tile-label { font-size: 0.4rem; letter-spacing: 0; margin-top: 1px; }
  .tile-number { font-size: 0.4rem; top: 0px; left: 1px; }
  .tile-state { font-size: 0.4rem; margin-top: 0; }
  
  .wall-progress { gap: 1px; margin-top: 1px; }
  .wall-brick { width: 6px; height: 4px; }
  
  .shield { font-size: 0.6rem; top: 0px; right: 0px; }
  
  .player-dot { width: 6px; height: 6px; border-width: 1px; }
  .tile-players { bottom: 1px; gap: 1px; }
  
  /* Climate bar */
  .climate-container { padding: 6px; margin-bottom: 5px; border-radius: 8px; }
  .climate-label { font-size: 0.7rem; margin-bottom: 4px; }
  .climate-bar { height: 14px; }
  .climate-status { font-size: 0.6rem; margin-top: 3px; }
  
  #log { 
    max-height: 60px; 
    font-size: 0.7rem; 
    padding: 6px;
    border-radius: 8px;
  }
  .log-entry { padding: 1px 0; }
  
  .rules-panel { display: none; } /* Hide on mobile to save space */
  
  .modal { padding: 10px; width: 95%; max-height: 85vh; }
  .modal h3 { font-size: 0.9rem; margin-bottom: 8px; }
  .modal-tiles { gap: 2px; max-width: 240px; }
  .modal-tile { padding: 2px; font-size: 0.5rem; min-height: 32px; border-radius: 3px; }
  .modal-tile .tile-icon { font-size: 0.85rem; }
  .modal-center { font-size: 0.6rem; padding: 3px; border-radius: 5px; }
  .btn-cancel { padding: 8px; font-size: 0.8rem; }
  
  .setup-modal { max-width: 95%; }
  .player-count-section { margin-bottom: 8px; }
  .player-count-buttons { gap: 4px; }
  .player-count-btn { width: 30px; height: 30px; font-size: 0.85rem; }
  .player-setup-row { padding: 5px; gap: 5px; flex-wrap: wrap; margin-bottom: 6px; }
  .player-name-input { padding: 5px; font-size: 0.8rem; min-width: 80px; }
  .color-option { width: 20px; height: 20px; border-width: 2px; }
  #player-setup { max-height: 40vh; }
  
  .dice-face-display { 
    width: 70px; 
    height: 70px; 
    line-height: 70px;
    font-size: 3.5rem;
    border-radius: 10px;
  }
  .dice-player-name { font-size: 0.9rem; }
  .dice-result-number { font-size: 1rem; }
  
  .victory-modal { max-width: 95%; padding: 12px; }
  .victory-icon { font-size: 2.5rem; }
  .victory-title { font-size: 1.2rem; letter-spacing: 1px; }
  .victory-message { font-size: 0.85rem; }
  .victory-player { padding: 4px 8px; font-size: 0.75rem; }
  .victory-stats { padding: 6px; font-size: 0.75rem; }
  .btn-restart { padding: 8px 20px; font-size: 0.9rem; }
  
  /* Tile info modal */
  .tile-info-modal { max-width: 90%; }
  .tile-info-header { gap: 8px; margin-bottom: 8px; padding-bottom: 8px; }
  .tile-info-icon { font-size: 1.8rem; width: 45px; height: 45px; }
  .tile-info-title h3 { font-size: 1rem; }
  .tile-info-rules { padding: 8px; }
  .tile-info-rules h4 { font-size: 0.85rem; }
  .tile-info-rules li { font-size: 0.75rem; padding: 3px 0; }
}

/* Even smaller screens (iPhone SE, etc.) */
@media (max-width: 380px) {
  h1 { font-size: 1.1rem; }
  .subtitle { font-size: 0.6rem; }
  
  .player-card { min-width: 38px; max-width: 60px; padding: 3px 4px; }
  .player-card .name { font-size: 0.55rem; }
  .player-card .money { font-size: 0.7rem; }
  
  .btn { font-size: 0.6rem; padding: 4px 2px; min-height: 28px; }
  
  #board { 
    max-width: 280px; 
    max-height: 280px;
    gap: 2px; 
  }
  .tile { padding: 0px; border-radius: 3px; border-width: 1px; }
  .tile-icon { font-size: 0.75rem; }
  .tile-label { display: none; }
  .tile-number { display: none; }
  .tile-state { display: none; }
  .shield { font-size: 0.5rem; top: -1px; right: -1px; }
  .wall-progress { display: none; }
  .player-dot { width: 5px; height: 5px; }
  
  .board-center > div:first-child { font-size: 0.9rem; }
  .board-center > div:nth-child(2) { font-size: 0.55rem; }
  
  .modal-tiles { max-width: 200px; gap: 1px; }
  .modal-tile { min-height: 28px; padding: 1px; }
  .modal-tile .tile-icon { font-size: 0.7rem; }
  .modal-center { font-size: 0.5rem; }
  
  .player-count-btn { width: 26px; height: 26px; font-size: 0.75rem; }
  .player-name-input { min-width: 70px; font-size: 0.75rem; padding: 4px; }
  .color-option { width: 18px; height: 18px; }
  
  #log { max-height: 50px; font-size: 0.65rem; }
  
  .climate-container { padding: 4px; }
  .climate-label { font-size: 0.6rem; }
  .climate-bar { height: 12px; }
  .climate-status { font-size: 0.55rem; }
}

/* Landscape phone */
@media (max-height: 500px) and (orientation: landscape) {
  .rules-panel { display: none; }
  #log { max-height: 40px; }
  h1 { padding-top: 5px; font-size: 1rem; margin-bottom: 2px; }
  .subtitle { display: none; }
  #player-panel { padding: 4px; margin-bottom: 4px; }
  .player-card { padding: 2px 4px; }
  .controls { margin-bottom: 4px; }
  #board { max-width: 250px; max-height: 250px; }
  .climate-container { display: none; }
}

/* ============ MULTIPLAYER LOBBY STYLES ============ */
.lobby-modal {
  max-width: 380px;
  width: 90%;
  text-align: center;
  background: rgba(15, 25, 45, 0.95);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 
    0 25px 50px rgba(0, 0, 0, 0.5),
    0 0 0 1px rgba(255, 255, 255, 0.05) inset;
  padding: 40px 32px;
  border-radius: 24px;
  position: relative;
  overflow: hidden;
}

.lobby-modal::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
}

.lobby-title {
  font-size: 1.8rem;
  margin-bottom: 6px;
  color: #fff;
  font-weight: 700;
  letter-spacing: -0.5px;
}

.lobby-subtitle {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.5);
  margin-bottom: 32px;
  font-weight: 400;
}

.lobby-wave {
  font-size: 3.5rem;
  margin-bottom: 16px;
  display: block;
}

.lobby-buttons {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 0;
  position: relative;
  z-index: 1;
}

.lobby-btn {
  padding: 16px 24px;
  font-size: 0.95rem;
  font-weight: 600;
  border: none;
  border-radius: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  position: relative;
  letter-spacing: 0;
  text-transform: none;
  background: #374151;
  color: white;
}

.lobby-btn:hover {
  transform: translateY(-2px);
}

.lobby-btn:active {
  transform: translateY(0) scale(0.98);
}

.lobby-btn-icon {
  font-size: 1.3rem;
}

.lobby-btn-create {
  background: #10b981;
  color: white;
  box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
}

.lobby-btn-create:hover {
  background: #059669;
  box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
}

.lobby-btn-join {
  background: #6366f1;
  color: white;
  box-shadow: 0 4px 14px rgba(99, 102, 241, 0.4);
}

.lobby-btn-join:hover {
  background: #4f46e5;
  box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
}

.lobby-btn-local {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: none;
}

.lobby-btn-local:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
}

.lobby-btn-secondary {
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.8);
  padding: 14px 20px;
  font-size: 0.9rem;
  box-shadow: none;
}

.lobby-btn-secondary:hover {
  background: rgba(255, 255, 255, 0.12);
  color: #fff;
}

.lobby-btn-back {
  background: #f59e0b;
  color: white;
  box-shadow: 0 4px 14px rgba(245, 158, 11, 0.4);
}

.lobby-btn-back:hover {
  background: #d97706;
  box-shadow: 0 6px 20px rgba(245, 158, 11, 0.5);
}

.lobby-btn-leave {
  background: #ef4444;
  color: white;
  box-shadow: 0 4px 14px rgba(239, 68, 68, 0.4);
}

.lobby-btn-leave:hover {
  background: #dc2626;
  box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
}

.lobby-divider {
  display: flex;
  align-items: center;
  margin: 16px 0;
  position: relative;
  z-index: 1;
}

.lobby-divider::before,
.lobby-divider::after {
  content: '';
  flex: 1;
  height: 1px;
  background: rgba(255, 255, 255, 0.15);
}

.lobby-divider span {
  padding: 0 16px;
  font-size: 0.8rem;
  text-transform: lowercase;
  letter-spacing: 0;
  color: rgba(255, 255, 255, 0.4);
  font-weight: 400;
}

.room-code-display {
  font-size: 2.2rem;
  font-weight: 700;
  letter-spacing: 8px;
  padding: 16px 24px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 12px;
  margin: 12px 0;
  font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
  color: #10b981;
  position: relative;
}

.room-code-label {
  font-size: 0.8rem;
  color: rgba(255, 255, 255, 0.5);
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 8px;
}

.room-code-input {
  font-size: 1.6rem;
  font-weight: 600;
  letter-spacing: 6px;
  padding: 14px 16px;
  text-align: center;
  text-transform: uppercase;
  background: rgba(255, 255, 255, 0.08);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  width: 100%;
  max-width: 200px;
  transition: all 0.2s ease;
  font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
}

.room-code-input:focus {
  outline: none;
  border-color: #6366f1;
  background: rgba(255, 255, 255, 0.12);
}

.room-code-input::placeholder {
  color: rgba(255, 255, 255, 0.3);
  letter-spacing: 4px;
}

.waiting-players {
  margin: 16px 0;
  text-align: left;
  max-height: 180px;
  overflow-y: auto;
}

.waiting-player {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 10px;
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

.waiting-player:hover {
  background: rgba(255, 255, 255, 0.08);
}

.waiting-player-dot {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.2);
}

.waiting-player-name {
  flex: 1;
  font-weight: 500;
  font-size: 0.95rem;
}

.waiting-player-badge {
  font-size: 0.65rem;
  font-weight: 600;
  padding: 3px 8px;
  border-radius: 6px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.waiting-player-host {
  background: #f59e0b;
  color: #000;
}

.waiting-player-you {
  background: #10b981;
  color: white;
}

.lobby-status {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.5);
  margin: 12px 0;
  padding: 8px;
}

.lobby-error {
  color: #f87171;
  font-size: 0.85rem;
  margin-top: 12px;
  padding: 10px 14px;
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: 8px;
}

.copy-btn {
  padding: 8px 16px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.7);
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  font-weight: 500;
  margin-top: 8px;
  transition: all 0.2s ease;
}

.copy-btn:hover {
  background: rgba(255, 255, 255, 0.12);
  color: #fff;
}

.online-indicator {
  display: inline-block;
  width: 10px;
  height: 10px;
  background: #4caf50;
  border-radius: 50%;
  margin-right: 5px;
  box-shadow: 0 0 10px #4caf50;
  animation: pulse-online 1.5s infinite;
}

@keyframes pulse-online {
  0%, 100% { opacity: 1; box-shadow: 0 0 10px #4caf50; }
  50% { opacity: 0.6; box-shadow: 0 0 20px #4caf50; }
}

.turn-indicator {
  position: fixed;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  padding: 12px 25px;
  border-radius: 25px;
  font-weight: bold;
  z-index: 100;
  display: none;
  border: 2px solid rgba(255,255,255,0.2);
}

.turn-indicator.your-turn {
  background: linear-gradient(135deg, #4caf50, #45a049);
  border-color: rgba(255,255,255,0.3);
  animation: pulse-turn 1s infinite;
}

@keyframes pulse-turn {
  0%, 100% { transform: translateX(-50%) scale(1); }
  50% { transform: translateX(-50%) scale(1.05); }
}

/* Mobile styles for lobby */
@media (max-width: 600px) {
  .lobby-modal { 
    max-width: 92%; 
    padding: 32px 24px;
    border-radius: 20px;
  }
  .lobby-title { font-size: 1.5rem; }
  .lobby-wave { font-size: 2.8rem; margin-bottom: 12px; }
  .lobby-subtitle { font-size: 0.85rem; margin-bottom: 24px; }
  .lobby-btn { 
    padding: 14px 18px; 
    font-size: 0.9rem; 
    border-radius: 12px;
  }
  .lobby-btn-icon { font-size: 1.2rem; }
  .room-code-display { 
    font-size: 1.8rem; 
    letter-spacing: 6px; 
    padding: 14px 18px; 
  }
  .room-code-input { 
    font-size: 1.4rem; 
    letter-spacing: 5px; 
    padding: 12px 14px;
    max-width: 180px;
  }
}

@media (max-width: 380px) {
  .lobby-modal { padding: 24px 18px; }
  .lobby-title { font-size: 1.3rem; }
  .lobby-wave { font-size: 2.2rem; }
  .lobby-btn { padding: 12px 14px; font-size: 0.85rem; gap: 8px; }
  .lobby-btn-icon { font-size: 1.1rem; }
  .room-code-display { font-size: 1.5rem; letter-spacing: 5px; }
  .room-code-input { font-size: 1.2rem; letter-spacing: 4px; }
}
</style>
</head>

<body>

<!-- Turn Indicator for Online Play -->
<div class="turn-indicator" id="turn-indicator"></div>

<!-- Multiplayer Lobby Modal -->
<div class="modal-overlay active" id="lobby-modal">
  <div class="modal lobby-modal">
    <!-- Main Menu -->
    <div id="lobby-menu">
      <div class="lobby-wave">üåä</div>
      <h3 class="lobby-title"><span data-i18n="title">Sink or Sell</span></h3>
      <p class="lobby-subtitle" data-i18n="chooseMode">Choose how to play</p>
      
      <div class="lobby-buttons">
        <button class="lobby-btn lobby-btn-create" onclick="createRoom()">
          <span class="lobby-btn-icon">üåê</span>
          <span data-i18n="createRoom">Create Online Room</span>
        </button>
        <button class="lobby-btn lobby-btn-join" onclick="showJoinRoom()">
          <span class="lobby-btn-icon">üîó</span>
          <span data-i18n="joinRoom">Join Online Room</span>
        </button>
        
        <div class="lobby-divider"><span>or</span></div>
        
        <button class="lobby-btn lobby-btn-local" onclick="playLocal()">
          <span class="lobby-btn-icon">üéÆ</span>
          <span data-i18n="playLocal">Play Locally</span>
        </button>
      </div>
    </div>
    
    <!-- Join Room View -->
    <div id="lobby-join" style="display:none;">
      <div class="lobby-wave">üîó</div>
      <h3 class="lobby-title" data-i18n="joinRoom">Join Room</h3>
      <p class="lobby-subtitle" data-i18n="enterCode">Enter room code</p>
      
      <input type="text" class="room-code-input" id="join-code-input" maxlength="4" placeholder="ABCD" oninput="this.value = this.value.toUpperCase()" autocomplete="off">
      <div class="lobby-error" id="join-error" style="display:none;"></div>
      
      <div style="margin-top:25px; display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        <button class="lobby-btn lobby-btn-join" style="flex:1; min-width:120px;" onclick="joinRoom()">
          <span class="lobby-btn-icon">‚úÖ</span>
          <span data-i18n="join">Join</span>
        </button>
        <button class="lobby-btn lobby-btn-back" style="flex:1; min-width:120px;" onclick="showLobbyMenu()">
          <span class="lobby-btn-icon">‚Üê</span>
          <span data-i18n="back">Back</span>
        </button>
      </div>
    </div>
    
    <!-- Waiting Room View -->
    <div id="lobby-waiting" style="display:none;">
      <p class="room-code-label" data-i18n="roomCode">Room Code</p>
      <div class="room-code-display" id="room-code-display">----</div>
      <button class="copy-btn" onclick="copyRoomCode()">üìã <span data-i18n="copyCode">Copy Code</span></button>
      
      <!-- My Player Customization -->
      <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.08); border-radius: 12px;">
        <p style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-bottom: 10px;" data-i18n="yourProfile">Your Profile</p>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <div class="player-emoji-display" id="my-emoji-display" onclick="openOnlineEmojiPicker()" style="width:45px; height:45px; font-size:1.6rem; cursor:pointer; background:rgba(255,255,255,0.1); border:2px solid rgba(255,255,255,0.3); border-radius:10px; display:flex; align-items:center; justify-content:center;">üòÄ</div>
          <input type="text" id="my-name-input" class="room-code-input" style="flex:1; font-size:1rem; letter-spacing:0; text-transform:none; max-width:none; padding:10px 12px;" placeholder="Your name" onchange="updateMyProfile()">
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 6px; justify-content: center;">
          ${COLOR_OPTIONS.map(c => `<div class="online-color-option" style="width:28px; height:28px; border-radius:50%; background:${c.value}; cursor:pointer; border:2px solid transparent;" onclick="selectOnlineColor('${c.value}')"></div>`).join('')}
        </div>
      </div>
      
      <div class="lobby-status">
        <span class="online-indicator"></span>
        <span data-i18n="waitingPlayers">Waiting for players...</span>
      </div>
      
      <div class="waiting-players" id="waiting-players"></div>
      
      <div id="host-controls">
        <button class="lobby-btn lobby-btn-create" style="width:100%; margin-top:10px;" onclick="startOnlineGame()">
          <span class="lobby-btn-icon">‚ñ∂Ô∏è</span>
          <span data-i18n="startOnlineGame">Start Game</span>
        </button>
      </div>
      
      <button class="lobby-btn lobby-btn-leave" style="width:100%; margin-top:15px;" onclick="leaveRoom()">
        <span class="lobby-btn-icon">üö™</span>
        <span data-i18n="leave">Leave Room</span>
      </button>
    </div>
  </div>
</div>

<!-- Emoji Picker Modal -->
<div class="modal-overlay" id="emoji-picker-modal">
  <div class="modal emoji-picker-modal">
    <h3 class="emoji-picker-title">üé≠ <span data-i18n="chooseEmoji">Choose Emoji</span></h3>
    <div class="emoji-picker-grid" id="emoji-picker-grid"></div>
    <button class="emoji-picker-close" onclick="closeEmojiPicker()">‚úñ <span data-i18n="cancel">Cancel</span></button>
  </div>
</div>

<!-- Language Toggle -->
<div class="lang-toggle">
  <button class="lang-btn active" id="lang-en" onclick="setLanguage('en')">üá¨üáß EN</button>
  <button class="lang-btn" id="lang-fr" onclick="setLanguage('fr')">üá´üá∑ FR</button>
</div>

<div class="game-container">
  <h1>üåä <span data-i18n="title">Sink or Sell</span></h1>
  <p class="subtitle" data-i18n="subtitle">Build, protect, and survive the rising tides!</p>

  <div id="player-panel">
    <div class="round-display"><span data-i18n="round">Round</span> <span id="round-num">1</span></div>
    <div id="climate-container">
      <div class="climate-label">üåç <span data-i18n="climate">Climate</span>: <span id="climate-value">0</span>/40 <span data-i18n="bricks">bricks</span></div>
      <div class="climate-bar">
        <div class="climate-fill" id="climate-fill"></div>
      </div>
      <div class="climate-status" id="climate-status">‚ö†Ô∏è <span data-i18n="unstable">Unstable - Crises are severe!</span></div>
    </div>
    <div class="players-row" id="players-row"></div>
  </div>

  <div class="controls">
    <button class="btn btn-buy" id="buyBtn" onclick="buy()">üè† <span data-i18n="buy">Buy</span> ($2)</button>
    <button class="btn btn-contribute" id="contributeBtn" onclick="openContributeModal()">üß± <span data-i18n="addBrick">+1 Brick</span> ($1)</button>
    <button class="btn btn-build" id="buildBtn" onclick="openBuildWallModal()">üõ°Ô∏è <span data-i18n="buildWall">Wall</span> ($4)</button>
    <button class="btn btn-end" id="endBtn" onclick="endTurn()">‚úÖ <span data-i18n="endTurn">End Turn</span></button>
  </div>

  <div id="board"></div>
  
  <div id="log"></div>

  <div class="rules-panel">
    <h2>üìú <span data-i18n="quickRules">Quick Rules</span></h2>
    <div class="rules-grid" id="rules-grid">
      <div class="rule-item">
        <h3>üé≤ Movement</h3>
        <p>Roll 1 die (1-6). Move clockwise. Pass START = +$2.</p>
      </div>
      <div class="rule-item">
        <h3>üè† Buy Property</h3>
        <p>Pay $2 to own. Rent = $1 + $1 per 4 bricks. Flooded = $0.</p>
      </div>
      <div class="rule-item">
        <h3>üß± Build Walls</h3>
        <p>$1 = +1 brick. $4 = +4 bricks. 4+ bricks = protected üõ°Ô∏è</p>
      </div>
      <div class="rule-item">
        <h3>‚õàÔ∏è Storm</h3>
        <p>Pick a tile: <b>-2 bricks</b>. No bricks? Dry‚ÜíFlooded‚ÜíSunk.</p>
      </div>
      <div class="rule-item">
        <h3>üåä Flood</h3>
        <p>Pick a tile: <b>ALL bricks destroyed!</b> Or damage tile.</p>
      </div>
      <div class="rule-item">
        <h3>ÔøΩ Sunken Tile</h3>
        <p>Land on sunk? Pay <b>$1</b> OR roll <b>6</b> to escape!</p>
      </div>
      <div class="rule-item">
        <h3>üåç Climate (total bricks)</h3>
        <p><b>20+</b>: Storms blocked. <b>30+</b>: Floods -2 only. <b>40</b>: üåü WIN!</p>
      </div>
      <div class="rule-item">
        <h3>üèÜ Victory</h3>
        <p>üåü <b>Collective</b>: 40 bricks!<br>üëë <b>Solo</b>: Last standing</p>
      </div>
    </div>
  </div>
</div>

<!-- Tile Selection Modal -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <h3 id="modal-title">Select a Tile</h3>
    <div class="modal-tiles" id="modal-tiles"></div>
    <button class="btn-cancel" onclick="closeModal()">Cancel</button>
  </div>
</div>

<!-- Tile Info Modal -->
<div class="modal-overlay" id="tile-info-modal">
  <div class="modal tile-info-modal">
    <div class="tile-info-header">
      <div class="tile-info-icon" id="tile-info-icon"></div>
      <div class="tile-info-title">
        <h3 id="tile-info-name"></h3>
        <span class="tile-type-badge" id="tile-info-badge"></span>
      </div>
    </div>
    <div class="tile-info-rules">
      <h4 id="tile-info-rules-title">How it works:</h4>
      <ul id="tile-info-rules-list"></ul>
    </div>
    <button class="btn-cancel" onclick="closeTileInfo()">Close</button>
  </div>
</div>

<!-- Dice Result Display -->
<div class="dice-result" id="dice-result">
  <div class="dice-player-name" id="dice-player-name"></div>
  <div class="dice-container">
    <div class="dice-face-display" id="dice-face"></div>
  </div>
  <div class="dice-result-number" id="dice-result-number"></div>
</div>

<!-- Setup Modal -->
<div class="modal-overlay active" id="setup-modal">
  <div class="modal setup-modal">
    <h3>üéÆ <span data-i18n="gameSetup">Game Setup</span></h3>
    
    <!-- Player Count Selection -->
    <div class="player-count-section">
      <p style="text-align:center; margin-bottom:10px; opacity:0.8;" data-i18n="selectPlayers">Number of Players</p>
      <div class="player-count-buttons" id="player-count-buttons">
        <button class="player-count-btn" onclick="setPlayerCount(2)">2</button>
        <button class="player-count-btn" onclick="setPlayerCount(3)">3</button>
        <button class="player-count-btn selected" onclick="setPlayerCount(4)">4</button>
        <button class="player-count-btn" onclick="setPlayerCount(5)">5</button>
        <button class="player-count-btn" onclick="setPlayerCount(6)">6</button>
        <button class="player-count-btn" onclick="setPlayerCount(7)">7</button>
        <button class="player-count-btn" onclick="setPlayerCount(8)">8</button>
      </div>
    </div>
    
    <p style="text-align:center; margin-bottom:15px; opacity:0.8;" data-i18n="chooseColors">Choose your colors (or leave default)</p>
    <div id="player-setup"></div>
    <button class="btn btn-roll" style="width:100%; margin-top:15px;" onclick="startGame()">‚ñ∂Ô∏è <span data-i18n="startGame">Start Game!</span></button>
  </div>
</div>

<!-- Victory Modal -->
<div class="modal-overlay" id="victory-modal">
  <div class="modal victory-modal" id="victory-content">
    <div class="victory-icon" id="victory-icon">üèÜ</div>
    <div class="victory-title" id="victory-title">VICTORY!</div>
    <div class="victory-message" id="victory-message"></div>
    <div class="victory-players" id="victory-players"></div>
    <div class="victory-stats" id="victory-stats"></div>
    <button class="btn-restart" onclick="restartGame()">üîÑ <span data-i18n="playAgain">Play Again</span></button>
  </div>
</div>

<script>
// ============ TRANSLATIONS ============
let currentLang = 'en';

const translations = {
  en: {
    title: "Sink or Sell",
    subtitle: "Build, protect, and survive the rising tides!",
    round: "Round",
    climate: "Climate",
    bricks: "bricks",
    unstable: "Unstable - Crises are severe!",
    buy: "Buy",
    addBrick: "+1 Brick",
    buildWall: "Wall",
    endTurn: "End",
    quickRules: "Quick Rules",
    cancel: "Cancel",
    gameSetup: "Game Setup",
    selectPlayers: "Number of Players",
    chooseColors: "Choose your colors (or leave default)",
    startGame: "Start Game!",
    playAgain: "Play Again",
    player: "Player",
    // Rules
    rules: [
      { icon: "üé≤", title: "Movement", desc: "Roll 1 die (1-6). Move clockwise. Pass START = +$2." },
      { icon: "üè†", title: "Buy Property", desc: "Pay $2 to own. Rent = $1 + $1 per 4 bricks. Flooded = $0." },
      { icon: "üß±", title: "Build Walls", desc: "$1 = +1 brick. $4 = +4 bricks. 4+ bricks = protected üõ°Ô∏è" },
      { icon: "‚õàÔ∏è", title: "Storm", desc: "Pick a tile: <b>-2 bricks</b>. No bricks? Dry‚ÜíFlooded‚ÜíSunk." },
      { icon: "üåä", title: "Flood", desc: "Pick a tile: <b>ALL bricks destroyed!</b> Or damage tile." },
      { icon: "üèä", title: "Sunken Tile", desc: "Land on sunk? Pay <b>$1</b> OR roll <b>6</b> to escape!" },
      { icon: "üåç", title: "Climate", desc: "<b>20+</b>: Storms blocked. <b>30+</b>: Floods -2 only. <b>40</b>: üåü WIN!" },
      { icon: "üèÜ", title: "Victory", desc: "üåü <b>Collective</b>: 40 bricks!<br>üëë <b>Solo</b>: Last standing" }
    ],
    // Climate statuses
    climateVictory: "VICTORY! Climate stabilized - EVERYONE WINS!",
    climateFloodsWeak: "Floods weakened! {n} bricks for COLLECTIVE WIN!",
    climateStormsBlocked: "Storms BLOCKED! {n} bricks to win!",
    climateStormsWeak: "Storms weakened. Need {n} more to block!",
    climateCritical: "CRITICAL! Storms do EXTRA damage! ({n} to stabilize)",
    // Victory
    collectiveVictory: "COLLECTIVE VICTORY!",
    winner: "WINNER!",
    gameOver: "GAME OVER",
    allWin: "ALL PLAYERS WIN TOGETHER!",
    roundsPlayed: "Rounds Played",
    tilesSunk: "Tiles Sunk",
    climateStable: "Climate stable",
    climateInDanger: "Climate in danger",
    // Tile labels
    tileLabels: {
      Start: "Start", Beach: "Beach", Harbor: "Harbor", Resort: "Resort",
      Village: "Village", Marina: "Marina", Pier: "Pier", Island: "Island",
      Storm: "Storm", Flood: "Flood", "Town Hall": "Town Hall", Workshop: "Workshop", Depot: "Depot"
    },
    // Multiplayer
    chooseMode: "Choose how to play:",
    createRoom: "Create Online Room",
    joinRoom: "Join Online Room",
    playLocal: "Play Locally",
    enterCode: "Enter room code:",
    join: "Join",
    back: "Back",
    roomCode: "Room Code:",
    copyCode: "Copy Code",
    waitingPlayers: "Waiting for players...",
    startOnlineGame: "Start Game",
    leave: "Leave Room",
    codeCopied: "Code copied!",
    roomNotFound: "Room not found",
    roomFull: "Room is full",
    roomStarted: "Game already started",
    yourTurn: "Your Turn!",
    waitingTurn: "Waiting for {player}...",
    youAre: "You are",
    host: "Host",
    chooseEmoji: "Choose Emoji"
  },
  fr: {
    title: "Couler ou Vendre",
    subtitle: "Construisez, prot√©gez et survivez aux mar√©es montantes !",
    round: "Tour",
    climate: "Climat",
    bricks: "briques",
    unstable: "Instable - Crises s√©v√®res !",
    buy: "Acheter",
    addBrick: "+1 Brique",
    buildWall: "Mur",
    endTurn: "Fin",
    quickRules: "R√®gles Rapides",
    cancel: "Annuler",
    gameSetup: "Configuration",
    selectPlayers: "Nombre de Joueurs",
    chooseColors: "Choisissez vos couleurs (ou gardez par d√©faut)",
    startGame: "Commencer !",
    playAgain: "Rejouer",
    player: "Joueur",
    // Rules
    rules: [
      { icon: "üé≤", title: "D√©placement", desc: "Lancez 1 d√© (1-6). Sens horaire. Passez D√âPART = +2‚Ç¨." },
      { icon: "üè†", title: "Acheter", desc: "Payez 2‚Ç¨ pour poss√©der. Loyer = 1‚Ç¨ + 1‚Ç¨ par 4 briques. Inond√© = 0‚Ç¨." },
      { icon: "üß±", title: "Construire", desc: "1‚Ç¨ = +1 brique. 4‚Ç¨ = +4 briques. 4+ briques = prot√©g√© üõ°Ô∏è" },
      { icon: "‚õàÔ∏è", title: "Temp√™te", desc: "Choisissez: <b>-2 briques</b>. Pas de briques? Sec‚ÜíInond√©‚ÜíCoul√©." },
      { icon: "üåä", title: "Inondation", desc: "Choisissez: <b>TOUTES les briques d√©truites!</b> Ou endommager." },
      { icon: "üèä", title: "Case Coul√©e", desc: "Atterrir sur coul√©? Payez <b>1‚Ç¨</b> OU faites <b>6</b> pour s'√©chapper!" },
      { icon: "üåç", title: "Climat", desc: "<b>20+</b>: Temp√™tes bloqu√©es. <b>30+</b>: Inondations -2. <b>40</b>: üåü VICTOIRE!" },
      { icon: "üèÜ", title: "Victoire", desc: "üåü <b>Collective</b>: 40 briques!<br>üëë <b>Solo</b>: Dernier debout" }
    ],
    // Climate statuses
    climateVictory: "VICTOIRE! Climat stabilis√© - TOUT LE MONDE GAGNE!",
    climateFloodsWeak: "Inondations affaiblies! {n} briques pour VICTOIRE COLLECTIVE!",
    climateStormsBlocked: "Temp√™tes BLOQU√âES! {n} briques pour gagner!",
    climateStormsWeak: "Temp√™tes affaiblies. Besoin de {n} de plus!",
    climateCritical: "CRITIQUE! Temp√™tes font des D√âG√ÇTS EXTRA! ({n} pour stabiliser)",
    // Victory
    collectiveVictory: "VICTOIRE COLLECTIVE!",
    winner: "GAGNANT!",
    gameOver: "FIN DE PARTIE",
    allWin: "TOUS LES JOUEURS GAGNENT ENSEMBLE!",
    roundsPlayed: "Tours jou√©s",
    tilesSunk: "Cases coul√©es",
    climateStable: "Climat stable",
    climateInDanger: "Climat en danger",
    // Tile labels
    tileLabels: {
      Start: "D√©part", Beach: "Plage", Harbor: "Port", Resort: "Station",
      Village: "Village", Marina: "Marina", Pier: "Jet√©e", Island: "√éle",
      Storm: "Temp√™te", Flood: "Inondation", "Town Hall": "Mairie", Workshop: "Atelier", Depot: "D√©p√¥t"
    },
    // Multiplayer
    chooseMode: "Choisissez comment jouer :",
    createRoom: "Cr√©er un Salon",
    joinRoom: "Rejoindre un Salon",
    playLocal: "Jouer en Local",
    enterCode: "Entrez le code du salon :",
    join: "Rejoindre",
    back: "Retour",
    roomCode: "Code du Salon :",
    copyCode: "Copier",
    waitingPlayers: "En attente de joueurs...",
    startOnlineGame: "Lancer la Partie",
    leave: "Quitter",
    codeCopied: "Code copi√© !",
    roomNotFound: "Salon introuvable",
    roomFull: "Salon complet",
    roomStarted: "Partie d√©j√† commenc√©e",
    yourTurn: "C'est ton tour !",
    waitingTurn: "En attente de {player}...",
    youAre: "Tu es",
    host: "H√¥te",
    chooseEmoji: "Choisir Emoji"
  }
};

function t(key) {
  return translations[currentLang][key] || translations['en'][key] || key;
}

function setLanguage(lang) {
  currentLang = lang;
  document.getElementById('lang-en').classList.toggle('active', lang === 'en');
  document.getElementById('lang-fr').classList.toggle('active', lang === 'fr');
  
  // Update all data-i18n elements
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    if (translations[lang][key]) {
      el.textContent = translations[lang][key];
    }
  });
  
  // Update rules
  renderRules();
  
  // Update climate display
  if (typeof updateClimateDisplay === 'function') {
    updateClimateDisplay();
  }
  
  // Re-render if game started
  if (gameStarted) {
    render();
  }
}

function renderRules() {
  const rulesGrid = document.getElementById('rules-grid');
  if (!rulesGrid) return;
  
  const rules = t('rules');
  rulesGrid.innerHTML = rules.map(rule => `
    <div class="rule-item">
      <h3>${rule.icon} ${rule.title}</h3>
      <p>${rule.desc}</p>
    </div>
  `).join('');
}

// ============ FIREBASE MULTIPLAYER ============
const firebaseConfig = {
  apiKey: "AIzaSyDmflc5tInmnmyCtyrXQNg8ZEJrz2_M6OI",
  authDomain: "jinjyweb-a909d.firebaseapp.com",
  databaseURL: "https://jinjyweb-a909d-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "jinjyweb-a909d",
  storageBucket: "jinjyweb-a909d.firebasestorage.app",
  messagingSenderId: "1005999363693",
  appId: "1:1005999363693:web:ec9890892b076536c6d164"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// Multiplayer state
let isOnlineMode = false;
let isHost = false;
let currentRoomCode = null;
let myPlayerId = null;
let myPlayerIndex = -1;
let roomRef = null;
let gameStateRef = null;

// Generate unique player ID
function generatePlayerId() {
  return 'player_' + Math.random().toString(36).substr(2, 9);
}

// Generate 4-letter room code
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 4; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Show lobby menu
function showLobbyMenu() {
  document.getElementById('lobby-menu').style.display = 'block';
  document.getElementById('lobby-join').style.display = 'none';
  document.getElementById('lobby-waiting').style.display = 'none';
  document.getElementById('join-error').style.display = 'none';
  document.getElementById('join-code-input').value = '';
}

// Play locally (skip lobby)
function playLocal() {
  isOnlineMode = false;
  document.getElementById('lobby-modal').classList.remove('active');
  document.getElementById('setup-modal').classList.add('active');
}

// Create online room
async function createRoom() {
  isHost = true;
  isOnlineMode = true;
  myPlayerId = generatePlayerId();
  currentRoomCode = generateRoomCode();
  
  const myEmoji = EMOJI_OPTIONS[Math.floor(Math.random() * EMOJI_OPTIONS.length)];
  const myColor = COLOR_OPTIONS[0].value;
  const myName = t('player') + ' 1';
  
  // Show waiting room
  document.getElementById('lobby-menu').style.display = 'none';
  document.getElementById('lobby-waiting').style.display = 'block';
  document.getElementById('room-code-display').textContent = currentRoomCode;
  document.getElementById('my-emoji-display').textContent = myEmoji;
  document.getElementById('my-name-input').value = myName;
  highlightMyColor(myColor);
  
  // Create room in Firebase
  roomRef = database.ref('rooms/' + currentRoomCode);
  
  const roomData = {
    host: myPlayerId,
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    status: 'waiting',
    players: {
      [myPlayerId]: {
        id: myPlayerId,
        name: myName,
        color: myColor,
        emoji: myEmoji,
        joinedAt: firebase.database.ServerValue.TIMESTAMP
      }
    }
  };
  
  await roomRef.set(roomData);
  
  // Listen for player changes
  roomRef.child('players').on('value', (snapshot) => {
    updateWaitingPlayers(snapshot.val());
  });
  
  // Listen for game start
  roomRef.child('status').on('value', (snapshot) => {
    if (snapshot.val() === 'playing') {
      startGameFromRoom();
    }
  });
  
  // Clean up on disconnect
  roomRef.child('players/' + myPlayerId).onDisconnect().remove();
}

// Show join room view
function showJoinRoom() {
  document.getElementById('lobby-menu').style.display = 'none';
  document.getElementById('lobby-join').style.display = 'block';
  document.getElementById('join-code-input').focus();
}

// Join existing room
async function joinRoom() {
  const codeInput = document.getElementById('join-code-input');
  const errorDiv = document.getElementById('join-error');
  const code = codeInput.value.toUpperCase().trim();
  
  if (code.length !== 4) {
    errorDiv.textContent = 'Enter a 4-letter code';
    errorDiv.style.display = 'block';
    return;
  }
  
  // Check if room exists
  roomRef = database.ref('rooms/' + code);
  const snapshot = await roomRef.once('value');
  const room = snapshot.val();
  
  if (!room) {
    errorDiv.textContent = t('roomNotFound');
    errorDiv.style.display = 'block';
    return;
  }
  
  if (room.status === 'playing') {
    errorDiv.textContent = t('roomStarted');
    errorDiv.style.display = 'block';
    return;
  }
  
  const playerCount = Object.keys(room.players || {}).length;
  if (playerCount >= 8) {
    errorDiv.textContent = t('roomFull');
    errorDiv.style.display = 'block';
    return;
  }
  
  // Join the room
  isHost = false;
  isOnlineMode = true;
  myPlayerId = generatePlayerId();
  currentRoomCode = code;
  
  const playerNum = playerCount + 1;
  const myEmoji = EMOJI_OPTIONS[playerNum - 1] || EMOJI_OPTIONS[Math.floor(Math.random() * EMOJI_OPTIONS.length)];
  const myColor = COLOR_OPTIONS[playerNum - 1]?.value || COLOR_OPTIONS[0].value;
  const myName = t('player') + ' ' + playerNum;
  
  await roomRef.child('players/' + myPlayerId).set({
    id: myPlayerId,
    name: myName,
    color: myColor,
    emoji: myEmoji,
    joinedAt: firebase.database.ServerValue.TIMESTAMP
  });
  
  // Show waiting room
  document.getElementById('lobby-join').style.display = 'none';
  document.getElementById('lobby-waiting').style.display = 'block';
  document.getElementById('room-code-display').textContent = code;
  document.getElementById('my-emoji-display').textContent = myEmoji;
  document.getElementById('my-name-input').value = myName;
  highlightMyColor(myColor);
  
  // Listen for player changes
  roomRef.child('players').on('value', (snapshot) => {
    updateWaitingPlayers(snapshot.val());
  });
  
  // Listen for game start
  roomRef.child('status').on('value', (snapshot) => {
    if (snapshot.val() === 'playing') {
      startGameFromRoom();
    }
  });
  
  // Clean up on disconnect
  roomRef.child('players/' + myPlayerId).onDisconnect().remove();
}

// Update waiting players list
function updateWaitingPlayers(playersData) {
  const container = document.getElementById('waiting-players');
  if (!playersData) {
    container.innerHTML = '';
    return;
  }
  
  const playersList = Object.values(playersData).sort((a, b) => a.joinedAt - b.joinedAt);
  
  container.innerHTML = playersList.map((p, idx) => {
    const isMe = p.id === myPlayerId;
    const isHostPlayer = idx === 0;
    return `
      <div class="waiting-player">
        <div class="waiting-player-dot" style="background:${p.color}; box-shadow: 0 0 10px ${p.color};"></div>
        <span class="waiting-player-name">${p.name}</span>
        ${isHostPlayer ? `<span class="waiting-player-badge waiting-player-host">üëë ${t('host')}</span>` : ''}
        ${isMe ? `<span class="waiting-player-badge waiting-player-you">‚ú® ${t('youAre')}</span>` : ''}
      </div>
    `;
  }).join('');
}

// Copy room code
function copyRoomCode() {
  navigator.clipboard.writeText(currentRoomCode).then(() => {
    const btn = document.querySelector('.copy-btn');
    const original = btn.innerHTML;
    btn.innerHTML = '‚úÖ ' + t('codeCopied');
    setTimeout(() => btn.innerHTML = original, 2000);
  });
}

// Leave room
function leaveRoom() {
  if (roomRef && myPlayerId) {
    roomRef.child('players/' + myPlayerId).remove();
    roomRef.off();
  }
  isOnlineMode = false;
  isHost = false;
  currentRoomCode = null;
  myPlayerId = null;
  roomRef = null;
  showLobbyMenu();
}

// Profile customization helpers
function highlightMyColor(color) {
  document.querySelectorAll('.online-color-option').forEach(el => {
    el.style.borderColor = el.style.background === color ? 'white' : 'transparent';
  });
}

function selectOnlineColor(color) {
  highlightMyColor(color);
  updateMyProfile();
}

function openOnlineEmojiPicker() {
  const modal = document.getElementById('emoji-picker-modal');
  const grid = document.getElementById('emoji-picker-grid');
  const currentEmoji = document.getElementById('my-emoji-display').textContent;
  grid.innerHTML = EMOJI_OPTIONS.map(e => `
    <div class="emoji-option ${currentEmoji === e ? 'selected' : ''}" 
         onclick="selectOnlineEmoji('${e}')">${e}</div>
  `).join('');
  modal.classList.add('active');
}

function selectOnlineEmoji(emoji) {
  document.getElementById('my-emoji-display').textContent = emoji;
  document.getElementById('emoji-picker-modal').classList.remove('active');
  updateMyProfile();
}

async function updateMyProfile() {
  if (!roomRef || !myPlayerId) return;
  
  const name = document.getElementById('my-name-input').value.trim() || t('player');
  const emoji = document.getElementById('my-emoji-display').textContent;
  let color = COLOR_OPTIONS[0].value;
  
  document.querySelectorAll('.online-color-option').forEach(el => {
    if (el.style.borderColor === 'white') {
      color = el.style.background;
    }
  });
  
  await roomRef.child('players/' + myPlayerId).update({
    name: name,
    emoji: emoji,
    color: color
  });
}

// Start online game (any player can start)
async function startOnlineGame() {
  try {
    console.log('Starting game... roomRef:', roomRef);
    
    if (!roomRef) {
      alert('Error: Not connected to room');
      return;
    }
    
    const snapshot = await roomRef.child('players').once('value');
    const playersData = snapshot.val();
    console.log('Players data:', playersData);
    
    const playersList = Object.values(playersData).sort((a, b) => a.joinedAt - b.joinedAt);
    
    if (playersList.length < 2) {
      alert('Need at least 2 players!');
      return;
    }
    
    // Initialize game state
    const initialGameState = {
      currentPlayer: 0,
      round: 1,
      totalBricks: 0,
      players: playersList.map((p, idx) => ({
        id: p.id,
        name: p.name,
        color: p.color,
        emoji: p.emoji || 'üòÄ',
        money: 5,
        pos: 0
      })),
      tiles: createInitialTiles(),
      lastAction: null,
      diceResult: null
    };
    
    console.log('Setting game state...');
    await roomRef.child('gameState').set(initialGameState);
    await roomRef.child('status').set('playing');
    console.log('Game started!');
  } catch (error) {
    console.error('Error starting game:', error);
    alert('Error starting game: ' + error.message);
  }
}

// Create initial tiles for sync
function createInitialTiles() {
  return tiles.map(tile => ({
    label: tile.label,
    icon: tile.icon,
    type: tile.type,
    state: tile.state,
    owner: tile.owner,
    bricks: tile.bricks
  }));
}

// Start game from room data
async function startGameFromRoom() {
  // Get game state
  const stateSnapshot = await roomRef.child('gameState').once('value');
  const state = stateSnapshot.val();
  
  if (!state) return;
  
  // Find my player index
  const myIndex = state.players.findIndex(p => p.id === myPlayerId);
  if (myIndex === -1) return;
  
  // Store my player index for turn checking
  myPlayerIndex = myIndex;
  
  // Set up local game state with player IDs
  players = state.players.map(p => ({
    id: p.id,
    name: p.name,
    color: p.color,
    emoji: p.emoji || 'üòÄ',
    money: p.money,
    pos: p.pos
  }));
  
  playerCount = players.length;
  current = state.currentPlayer;
  round = state.round;
  totalBricks = state.totalBricks || 0;
  rolled = false;
  
  // Sync tiles
  state.tiles.forEach((t, i) => {
    tiles[i].state = t.state;
    tiles[i].owner = t.owner;
    tiles[i].bricks = t.bricks;
  });
  
  // Close lobby, open game
  document.getElementById('lobby-modal').classList.remove('active');
  document.getElementById('setup-modal').classList.remove('active');
  
  gameStarted = true;
  gameOver = false;
  
  // Listen for game state changes
  gameStateRef = roomRef.child('gameState');
  gameStateRef.on('value', (snapshot) => {
    const newState = snapshot.val();
    if (newState) {
      syncGameState(newState);
    }
  });
  
  render();
  updateTurnIndicator();
  
  // Auto-roll if it's my turn (first player)
  if (myPlayerIndex === 0) {
    setTimeout(() => autoRoll(), 1000);
  }
}

// Sync game state from Firebase
function syncGameState(state) {
  if (!isOnlineMode || !state) return;
  
  // Update players
  state.players.forEach((p, i) => {
    if (players[i]) {
      players[i].id = p.id;
      players[i].money = p.money;
      players[i].pos = p.pos;
    }
  });
  
  // Update tiles
  state.tiles.forEach((t, i) => {
    if (tiles[i]) {
      tiles[i].state = t.state;
      tiles[i].owner = t.owner;
      tiles[i].bricks = t.bricks;
    }
  });
  
  current = state.currentPlayer;
  round = state.round;
  totalBricks = state.totalBricks || 0;
  
  // Handle dice result animation
  if (state.diceResult && state.lastAction === 'roll') {
    showDiceResult(state.diceResult.value, state.diceResult.playerName);
  }
  
  render();
  updateTurnIndicator();
  
  // Auto-roll if it's now my turn and not yet rolled
  if (myPlayerIndex === current && !rolled) {
    setTimeout(() => autoRoll(), 500);
  }
}

// Check if it's my turn
function isMyTurn() {
  if (!isOnlineMode) return true;
  const myIndex = players.findIndex((p, i) => {
    const statePlayer = gameStateRef ? players[i] : null;
    return statePlayer && players[i].name === players[currentPlayer].name;
  });
  return players[currentPlayer]?.name === players.find((p, i) => {
    return roomRef && myPlayerId && p.name.includes(myPlayerId.slice(-4));
  })?.name || currentPlayer === players.findIndex((_, i) => {
    // Find by checking which player I am
    const snapshot = roomRef?.child('gameState/players');
    return true;
  });
}

// Simplified: check my turn by player ID stored in state
function checkMyTurn() {
  if (!isOnlineMode) return true;
  
  // In online mode, find which player index I am
  return new Promise(async (resolve) => {
    const stateSnapshot = await roomRef.child('gameState').once('value');
    const state = stateSnapshot.val();
    if (!state) { resolve(true); return; }
    
    const myIndex = state.players.findIndex(p => p.id === myPlayerId);
    resolve(myIndex === state.currentPlayer);
  });
}

// Update turn indicator
function updateTurnIndicator() {
  if (!isOnlineMode) {
    document.getElementById('turn-indicator').style.display = 'none';
    return;
  }
  
  const indicator = document.getElementById('turn-indicator');
  indicator.style.display = 'block';
  
  if (myPlayerIndex === current) {
    indicator.textContent = 'üéØ ' + t('yourTurn');
    indicator.classList.add('your-turn');
  } else {
    const currentName = players[current]?.name || 'Player';
    indicator.textContent = t('waitingTurn').replace('{player}', currentName);
    indicator.classList.remove('your-turn');
  }
}

// Push game state to Firebase
async function pushGameState(action = null, extra = {}) {
  if (!isOnlineMode || !gameStateRef) return;
  
  const state = {
    currentPlayer: current,
    round,
    totalBricks,
    players: players.map((p, i) => {
      return {
        id: p.id || ('player_' + i),
        name: p.name,
        color: p.color,
        emoji: p.emoji || 'üòÄ',
        money: p.money,
        pos: p.pos
      };
    }),
    tiles: tiles.map(t => ({
      label: t.label,
      icon: t.icon,
      type: t.type,
      state: t.state,
      owner: t.owner,
      bricks: t.bricks
    })),
    lastAction: action,
    ...extra
  };
  
  // Preserve player IDs
  const existingState = await gameStateRef.once('value');
  if (existingState.val()?.players) {
    state.players = state.players.map((p, i) => ({
      ...p,
      id: existingState.val().players[i]?.id || p.id
    }));
  }
  
  await gameStateRef.set(state);
}

// ============ GAME CODE ============
const DICE_FACES = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'];

const COLOR_OPTIONS = [
  { name: "Red", value: "#e74c3c" },
  { name: "Blue", value: "#3498db" },
  { name: "Green", value: "#2ecc71" },
  { name: "Purple", value: "#9b59b6" },
  { name: "Orange", value: "#e67e22" },
  { name: "Pink", value: "#e91e63" },
  { name: "Cyan", value: "#00bcd4" },
  { name: "Yellow", value: "#f1c40f" },
  { name: "Lime", value: "#8bc34a" },
  { name: "Teal", value: "#009688" },
  { name: "Indigo", value: "#3f51b5" },
  { name: "Brown", value: "#795548" }
];

const EMOJI_OPTIONS = [
  "üòÄ", "üòé", "ü§†", "ü•≥", "üò∫", "üê∂", "ü¶ä", "üê∏",
  "ü¶Ñ", "üêô", "ü¶ã", "üåü", "üî•", "üíé", "üéØ", "üöÄ",
  "üåà", "üçÄ", "üéÆ", "üëë", "ü¶Å", "üêº", "ü¶â", "üêù"
];

let playerCount = 4;
let players = [];

function initPlayers(count) {
  players = [];
  for (let i = 0; i < count; i++) {
    players.push({
      name: `${t('player')} ${i + 1}`,
      color: COLOR_OPTIONS[i % COLOR_OPTIONS.length].value,
      emoji: EMOJI_OPTIONS[i % EMOJI_OPTIONS.length],
      money: 5,
      pos: 0
    });
  }
}

// Initialize with default 4 players
initPlayers(4);

function setPlayerCount(count) {
  playerCount = count;
  initPlayers(count);
  
  // Update button selection
  document.querySelectorAll('.player-count-btn').forEach(btn => {
    btn.classList.remove('selected');
    if (parseInt(btn.textContent) === count) {
      btn.classList.add('selected');
    }
  });
  
  // Refresh player setup UI
  initSetup();
}

let current = 0, rolled = false, round = 1;
let gameStarted = false;
let modalCallback = null;

const tileConfig = [
  { type: "start", icon: "üöÄ", label: "Start" },
  { type: "property", icon: "üè†", label: "Beach" },
  { type: "storm", icon: "‚õàÔ∏è", label: "Storm" },
  { type: "property", icon: "üè°", label: "Harbor" },
  { type: "policy", icon: "üèõÔ∏è", label: "Town Hall" },
  { type: "property", icon: "üè¢", label: "Resort" },
  { type: "flood", icon: "üåä", label: "Flood" },
  { type: "property", icon: "üèòÔ∏è", label: "Village" },
  { type: "storm", icon: "‚õàÔ∏è", label: "Storm" },
  { type: "property", icon: "‚õµ", label: "Marina" },
  { type: "policy", icon: "üèóÔ∏è", label: "Workshop" },
  { type: "property", icon: "üé°", label: "Pier" },
  { type: "flood", icon: "üåä", label: "Flood" },
  { type: "property", icon: "üå¥", label: "Island" },
  { type: "storm", icon: "‚õàÔ∏è", label: "Storm" },
  { type: "policy", icon: "üîß", label: "Depot" }
];

const tiles = tileConfig.map((cfg, i) => ({
  ...cfg,
  owner: null,
  state: "dry",
  bricks: 0  // total bricks (4+ = protected)
}));

function render() {
  // Update round
  document.getElementById("round-num").textContent = round;
  
  // Update climate stability display
  updateClimateDisplay();
  
  // Update players row
  const playersRow = document.getElementById("players-row");
  playersRow.innerHTML = players.map((p, i) => `
    <div class="player-card ${i === current ? 'active' : ''}" style="border-color: ${i === current ? p.color : 'transparent'}">
      <div class="token" style="background: ${p.color}">${p.emoji || ''}</div>
      <div class="name" style="color: ${p.color}">${p.name}</div>
      <div class="money">$${p.money}</div>
    </div>
  `).join('');

  // Update board
  const board = document.getElementById("board");
  board.innerHTML = tiles.map((t, i) => {
    const playersHere = players.filter(p => p.pos === i);
    const ownerStyle = t.owner !== null ? `border-color: ${players[t.owner].color}; box-shadow: 0 0 10px ${players[t.owner].color}40;` : '';
    
    return `
      <div class="tile ${t.type} ${t.state === 'flooded' ? 'flooded' : ''} ${t.state === 'sunk' ? 'sunk' : ''}" data-pos="${i}" onclick="showTileInfo(${i})" style="${ownerStyle}">
        <span class="tile-number">${i}</span>
        ${t.bricks >= 4 ? '<span class="shield">üõ°Ô∏è</span>' : ''}
        <div class="tile-icon">${t.icon}</div>
        <div class="tile-label">${t.label}</div>
        ${t.state !== 'dry' ? `<div class="tile-state">${t.state === 'flooded' ? 'üíß Flooded' : 'üíÄ Sunk'}</div>` : ''}
        ${(t.type === 'property' || t.type === 'policy') && t.state !== 'sunk' ? `
          <div class="wall-progress">
            ${[0,1,2,3].map(j => `<div class="wall-brick ${j < (t.bricks % 4) || t.bricks >= 4 && j < 4 ? 'filled' : ''}"></div>`).join('')}
          </div>
          ${t.bricks > 0 ? `<div style="font-size:0.6rem;">üß±${t.bricks}</div>` : ''}
        ` : ''}
        <div class="tile-players">
          ${playersHere.map(p => `<div class="player-dot" style="background: ${p.color}; font-size: 0.5rem; display: flex; align-items: center; justify-content: center;">${p.emoji || ''}</div>`).join('')}
        </div>
      </div>
    `;
  }).join('') + `
    <div class="board-center">
      <div style="font-size: 2rem;">üåä</div>
      <div style="font-size: 1.2rem; font-weight: bold;">Sink or Sell</div>
      <div style="font-size: 0.8rem; opacity: 0.7; margin-top: 5px;" data-i18n="subtitle">${t('subtitle')}</div>
    </div>
  `;
  
  // Update button states
  updateButtons();
}

function updateButtons() {
  const p = players[current];
  const t = tiles[p.pos];
  
  // Buy button - need $2, must have rolled, tile must be property, unowned, and dry
  const canBuy = rolled && t.type === "property" && t.owner === null && t.state === "dry" && p.money >= 2;
  document.getElementById("buyBtn").disabled = !canBuy;
  
  // Contribute button - need $1
  document.getElementById("contributeBtn").disabled = p.money < 1;
  
  // Build wall button - need $4
  document.getElementById("buildBtn").disabled = p.money < 4;
}

function log(msg) {
  const l = document.getElementById("log");
  l.innerHTML += `<div class="log-entry">${msg}</div>`;
  l.scrollTop = l.scrollHeight;
}

function showDice(playerName, playerColor, finalValue, callback) {
  const dice = document.getElementById("dice-result");
  const diceFace = document.getElementById("dice-face");
  const dicePlayerName = document.getElementById("dice-player-name");
  const diceResultNumber = document.getElementById("dice-result-number");
  
  dicePlayerName.textContent = `üé≤ ${playerName}'s turn`;
  dicePlayerName.style.color = playerColor;
  diceResultNumber.textContent = '';
  
  dice.style.display = "block";
  dice.className = "dice-result rolling";
  
  // Rolling animation - faster with fewer rolls
  let rollCount = 0;
  const maxRolls = 10;
  
  function rollOnce() {
    diceFace.textContent = DICE_FACES[Math.floor(Math.random() * 6)];
    rollCount++;
    
    if (rollCount < maxRolls) {
      // Quick rolls that slow down at the end
      const delay = 40 + (rollCount * 8);
      setTimeout(rollOnce, delay);
    } else {
      // Show final result with bounce
      diceFace.textContent = DICE_FACES[finalValue - 1];
      dice.className = "dice-result bounce";
      diceResultNumber.textContent = `Rolled a ${finalValue}!`;
      
      // Fade out faster
      setTimeout(() => {
        dice.className = "dice-result final";
        
        setTimeout(() => {
          dice.style.display = "none";
          dice.className = "dice-result";
          if (callback) callback();
        }, 400);
      }, 700);
    }
  }
  
  rollOnce();
}

function autoRoll() {
  if (rolled) return;
  
  // In online mode, check if it's my turn
  if (isOnlineMode) {
    if (myPlayerIndex !== current) {
      // Not my turn - wait for sync
      console.log('Not my turn. myPlayerIndex:', myPlayerIndex, 'current:', current);
      return;
    }
    doRoll();
  } else {
    doRoll();
  }
}

function doRoll() {
  rolled = true;
  
  const rollValue = Math.floor(Math.random() * 6) + 1;
  const p = players[current];
  
  // Disable buttons during roll
  document.getElementById("buyBtn").disabled = true;
  document.getElementById("contributeBtn").disabled = true;
  document.getElementById("buildBtn").disabled = true;
  document.getElementById("endBtn").disabled = true;
  
  showDice(p.name, p.color, rollValue, () => {
    const oldPos = p.pos;
    p.pos = (p.pos + rollValue) % 16;
    
    if (oldPos > p.pos || (oldPos + rollValue >= 16)) {
      p.money += 2;
      log(`‚ú® ${p.name} passes START and earns $2!`);
    }
    
    log(`üé≤ ${p.name} rolls ${rollValue} ‚Üí moves to tile ${p.pos} (${tiles[p.pos].label})`);
    
    // Sync to Firebase
    if (isOnlineMode) {
      pushGameState('roll', { diceResult: { value: rollValue, playerName: p.name } });
    }
    
    resolve();
    render();
    
    // Re-enable end turn button
    document.getElementById("endBtn").disabled = false;
  });
}

function resolve() {
  const p = players[current];
  const t = tiles[p.pos];
  const climate = getClimateStability();

  // Storm tile - effect depends on climate!
  if (t.type === "storm") {
    if (climate >= 12) {
      // Climate is stable enough - storm is prevented!
      log(`‚õàÔ∏è ${p.name} lands on Storm, but üåç CLIMATE IS STABLE! The storm passes harmlessly.`);
      log(`üü¢ Collective walls protect the coast!`);
      render();
      return;
    } else if (climate >= 8) {
      // Weakened storm - only targets unprotected tiles
      log(`‚õàÔ∏è Weakened storm! (üåç Climate ${climate}/12 needed to prevent)`);
      openStormModal();
      return;
    } else {
      // Full storm + extra damage at very low climate
      if (climate < 4) {
        log(`üí• SEVERE STORM! (üåç Climate too low - crisis intensified!)`);
      }
      openStormModal();
      return;
    }
  }
  
  // Flood tile - effect depends on climate!
  if (t.type === "flood") {
    if (climate >= 15) {
      // Climate very stable - flood becomes just a storm
      log(`üåä ${p.name} lands on Flood, but üåç CLIMATE IS VERY STABLE!`);
      log(`üü¢ The flood is reduced to a minor storm.`);
      openStormModal(); // Downgraded to storm!
      return;
    } else if (climate >= 10) {
      // Weakened flood - only destroys 1 layer instead of all
      log(`üåä Weakened flood! (üåç Climate reduces damage)`);
      openWeakFloodModal();
      return;
    } else {
      // Full devastating flood
      if (climate < 4) {
        log(`üí• CATASTROPHIC FLOOD! (üåç Climate too low!)`);
      }
      openFloodModal();
      return;
    }
  }

  // Policy tiles - special effects!
  if (t.type === "policy") {
    if (t.label === "Town Hall") {
      log(`üèõÔ∏è ${p.name} visits Town Hall - choose a tile to add 1 FREE brick!`);
      openFreeBrickModal();
      return;
    } else if (t.label === "Workshop") {
      p.money += 1;
      log(`üèóÔ∏è ${p.name} visits Workshop and earns +$1 bonus!`);
    } else if (t.label === "Depot") {
      // Check if there are flooded tiles to repair
      const floodedTiles = tiles.filter(tile => tile.state === "flooded");
      if (floodedTiles.length > 0) {
        log(`üîß ${p.name} visits Depot - choose a flooded tile to repair!`);
        openRepairModal();
        return;
      } else {
        log(`üîß ${p.name} visits Depot, but no flooded tiles to repair.`);
      }
    }
  }

  // Sunken tile - player must pay $1 OR roll a 6 to escape!
  if (t.state === "sunk") {
    log(`üåä ${p.name} falls into the sunken ruins of ${t.label}!`);
    openRescueModal();
    return;
  }

  // Pay rent based on tile state and bricks
  if (t.owner !== null && t.owner !== current) {
    if (t.state === "dry") {
      // Rent = $1 base + $1 per 4 bricks
      const wallBonus = Math.floor(t.bricks / 4);
      const rent = 1 + wallBonus;
      p.money = Math.max(0, p.money - rent);
      players[t.owner].money += rent;
      if (wallBonus > 0) {
        log(`üí∏ ${p.name} pays $${rent} rent to ${players[t.owner].name} (base $1 + ${wallBonus} wall bonus)`);
      } else {
        log(`üí∏ ${p.name} pays $1 rent to ${players[t.owner].name}`);
      }
    } else if (t.state === "flooded") {
      // No rent on flooded property
      log(`üíß ${p.name} lands on flooded ${t.label} - no rent due! (property damaged)`);
    }
  }
  
  render();
}

function buy() {
  const p = players[current];
  const t = tiles[p.pos];
  
  if (!rolled || t.type !== "property" || t.owner !== null || t.state !== "dry" || p.money < 2) return;
  
  p.money -= 2;
  t.owner = current;
  log(`üè† ${p.name} buys ${t.label} (tile ${p.pos}) for $2`);
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('buy');
  
  render();
}

function openContributeModal() {
  const p = players[current];
  if (p.money < 1) return;
  
  document.getElementById("modal-title").textContent = "üß± Add 1 brick ($1)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    // Can't add to start, storm, flood, or sunk
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    // Show icon for disabled tiles, bricks for enabled tiles
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectContribute(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üß±<br>Select tile</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectContribute(tileIndex) {
  const p = players[current];
  const t = tiles[tileIndex];
  
  p.money -= 1;
  t.bricks++;
  
  if (t.bricks === 4) {
    log(`üß± ${p.name} adds brick to ${t.label} - now PROTECTED! üõ°Ô∏è (${t.bricks} bricks)`);
  } else {
    log(`üß± ${p.name} adds brick to ${t.label} (${t.bricks} bricks)`);
  }
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('contribute');
  
  closeModal();
  render();
  checkWinCondition(); // Check for collective victory
}

function openFreeBrickModal() {
  document.getElementById("modal-title").textContent = "üèõÔ∏è Town Hall: Add 1 FREE brick to any tile";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectFreeBrick(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üèõÔ∏è<br>FREE brick</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectFreeBrick(tileIndex) {
  const p = players[current];
  const t = tiles[tileIndex];
  
  t.bricks++;
  
  if (t.bricks === 4) {
    log(`üèõÔ∏è ${p.name} adds FREE brick to ${t.label} - now PROTECTED! üõ°Ô∏è (${t.bricks} bricks)`);
  } else {
    log(`üèõÔ∏è ${p.name} adds FREE brick to ${t.label} (${t.bricks} bricks)`);
  }
  
  closeModal();
  checkWinCondition(); // Check for collective victory;
  
  // Continue with rent check
  const currentTile = tiles[p.pos];
  if (currentTile.owner !== null && currentTile.owner !== current && currentTile.state === "dry") {
    const wallBonus = Math.floor(currentTile.bricks / 4);
    const rent = 1 + wallBonus;
    p.money = Math.max(0, p.money - rent);
    players[currentTile.owner].money += rent;
    log(`üí∏ ${p.name} pays $${rent} rent to ${players[currentTile.owner].name}`);
  }
  
  render();
}

function openBuildWallModal() {
  const p = players[current];
  if (p.money < 4) return;
  
  document.getElementById("modal-title").textContent = "üõ°Ô∏è Build wall (+4 bricks for $4)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    // Can't build on start, storm, flood, or sunk
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectBuildWall(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üõ°Ô∏è<br>Build wall</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectBuildWall(tileIndex) {
  const p = players[current];
  const t = tiles[tileIndex];
  
  p.money -= 4;
  t.bricks += 4;
  
  log(`üõ°Ô∏è ${p.name} builds wall on ${t.label} for $4! (${t.bricks} bricks total)`);
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('buildWall');
  
  closeModal();
  render();
}

function openRepairModal() {
  document.getElementById("modal-title").textContent = "üîß Depot: Choose a flooded tile to repair (FREE)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    const disabled = t.state !== "flooded";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = `<span class="tile-icon">${t.icon}</span>`;
    if (!disabled) {
      content += `<br>üíß Flooded`;
    } else if (t.bricks > 0) {
      content += `<br>üß±${t.bricks} ${t.bricks >= 4 ? 'üõ°Ô∏è' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectRepair(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üîß<br>Repair</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectRepair(tileIndex) {
  const p = players[current];
  const t = tiles[tileIndex];
  
  t.state = "dry";
  t.bricks++; // Bonus brick for repairing
  log(`üîß ${p.name} repairs ${t.label} - it's DRY again! (+1 brick bonus, now ${t.bricks})`);
  
  closeModal();
  checkWinCondition(); // Check for collective victory;
  
  // Continue with rent check
  const currentTile = tiles[p.pos];
  if (currentTile.owner !== null && currentTile.owner !== current && currentTile.state === "dry") {
    const wallBonus = Math.floor(currentTile.bricks / 4);
    const rent = 1 + wallBonus;
    p.money = Math.max(0, p.money - rent);
    players[currentTile.owner].money += rent;
    log(`üí∏ ${p.name} pays $${rent} rent to ${players[currentTile.owner].name}`);
  }
  
  render();
}

// Rescue modal for sunken tiles - pay $1 or roll 6
function openRescueModal() {
  const p = players[current];
  const canPay = p.money >= 1;
  
  document.getElementById("modal-title").textContent = "üèä RESCUE! Pay $1 or roll a 6 to escape!";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = `
    <div style="display: flex; flex-direction: column; gap: 15px; padding: 20px; width: 100%;">
      <div style="text-align: center; font-size: 1.2rem; margin-bottom: 10px;">
        üíÄ You're trapped in sunken ruins!
      </div>
      <button class="btn btn-buy" style="padding: 20px; font-size: 1.3rem; ${!canPay ? 'opacity: 0.4; cursor: not-allowed;' : ''}" 
              onclick="${canPay ? 'selectRescuePay()' : ''}" ${!canPay ? 'disabled' : ''}>
        üí∞ Pay $1 to escape
      </button>
      <div style="text-align: center; font-size: 1rem; color: #aaa;">‚Äî OR ‚Äî</div>
      <button class="btn btn-roll" style="padding: 20px; font-size: 1.3rem;" onclick="selectRescueRoll()">
        üé≤ Roll dice (need a 6!)
      </button>
      ${!canPay ? '<div style="text-align: center; color: #ff6b6b; font-size: 0.9rem;">‚ö†Ô∏è No money - you must roll!</div>' : ''}
    </div>
  `;
  
  document.getElementById("modal").classList.add("active");
}

function selectRescuePay() {
  const p = players[current];
  p.money -= 1;
  log(`üí∞ ${p.name} pays $1 to escape the ruins!`);
  closeModal();
  render();
}

function selectRescueRoll() {
  closeModal();
  const p = players[current];
  const rollValue = Math.floor(Math.random() * 6) + 1;
  
  showDice(p.name + " (Rescue!)", "#ff6b6b", rollValue, () => {
    if (rollValue === 6) {
      log(`üé≤ ${p.name} rolls a ${rollValue}! üéâ ESCAPED FOR FREE!`);
    } else {
      log(`üé≤ ${p.name} rolls a ${rollValue}... Still trapped! üíÄ`);
      // Player loses their turn but doesn't lose money
    }
    render();
  });
}

function openStormModal() {
  document.getElementById("modal-title").textContent = "‚õàÔ∏è STORM! Select a tile (-2 bricks)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    // Can't target start, storm, flood, or already sunk
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : t.state === 'flooded' ? '<br>üíß' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectStorm(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">‚õàÔ∏è<br>Storm!</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectStorm(tileIndex) {
  const t = tiles[tileIndex];
  const climate = getClimateStability();
  
  // Storm removes 2 bricks
  if (t.bricks > 0) {
    const damage = Math.min(2, t.bricks);
    t.bricks -= damage;
    log(`‚õàÔ∏è Storm hits ${t.label} - ${damage} brick${damage > 1 ? 's' : ''} destroyed! (${t.bricks} remain)`);
    if (t.bricks < 4 && t.bricks >= 0) {
      log(`‚ö†Ô∏è ${t.label} is no longer fully protected!`);
    }
  } else if (t.state === "dry") {
    t.state = "flooded";
    log(`‚õàÔ∏è Storm floods ${t.label}!`);
    // At low climate, extra damage
    if (climate < 8) {
      const wallTiles = tiles.filter(tile => tile.bricks > 0);
      if (wallTiles.length > 0) {
        const randomTile = wallTiles[Math.floor(Math.random() * wallTiles.length)];
        randomTile.bricks--;
        log(`üí® Severe winds also damage 1 brick on ${randomTile.label}!`);
      }
    }
  } else if (t.state === "flooded") {
    t.state = "sunk";
    t.owner = null;
    t.bricks = 0;
    log(`üíÄ Storm sinks ${t.label}! It's destroyed forever.`);
  }
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('storm');
  
  closeModal();
  finishTurnAfterCrisis();
}

function openFloodModal() {
  document.getElementById("modal-title").textContent = "üåä FLOOD! Select a tile (ALL bricks destroyed!)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    // Can't target start, storm, flood, or already sunk
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : t.state === 'flooded' ? '<br>üíß' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectFlood(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üåä<br>Flood!</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function openWeakFloodModal() {
  document.getElementById("modal-title").textContent = "üåä Weakened Flood (-2 bricks only)";
  const modalTiles = document.getElementById("modal-tiles");
  
  modalTiles.innerHTML = tiles.map((t, i) => {
    const disabled = t.type === "start" || t.type === "storm" || t.type === "flood" || t.state === "sunk";
    const ownerColor = t.owner !== null ? players[t.owner].color : null;
    const ownerStyle = ownerColor ? `border: 3px solid ${ownerColor}; box-shadow: 0 0 5px ${ownerColor};` : '';
    
    let content = '';
    if (disabled) {
      content = `<span class="tile-icon">${t.icon}</span>`;
    } else {
      content = `<span class="tile-icon">${t.icon}</span>${t.bricks > 0 ? `<br>üß±${t.bricks}` : ''} ${t.bricks >= 4 ? 'üõ°Ô∏è' : t.state === 'flooded' ? '<br>üíß' : ''}`;
    }
    
    return `
      <div class="modal-tile ${t.type} ${t.state === 'sunk' ? 'sunk' : ''} ${disabled ? 'disabled' : ''}" 
           data-pos="${i}"
           style="${ownerStyle}"
           onclick="${disabled ? '' : `selectWeakFlood(${i})`}">
        ${content}
      </div>
    `;
  }).join('') + `<div class="modal-center">üåä<br>Weak flood</div>`;
  
  document.getElementById("modal").classList.add("active");
}

function selectWeakFlood(tileIndex) {
  const t = tiles[tileIndex];
  
  // Weakened flood only removes 2 bricks (like a storm)
  if (t.bricks > 0) {
    const damage = Math.min(2, t.bricks);
    t.bricks -= damage;
    log(`üåä Weakened flood hits ${t.label} - ${damage} brick${damage > 1 ? 's' : ''} destroyed! (üåç Climate helped!)`);
  } else if (t.state === "dry") {
    t.state = "flooded";
    log(`üåä Flood hits ${t.label} - now FLOODED!`);
  } else if (t.state === "flooded") {
    t.state = "sunk";
    t.owner = null;
    log(`üíÄ Flood sinks ${t.label}!`);
  }
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('weakFlood');
  
  closeModal();
  finishTurnAfterCrisis();
}

function selectFlood(tileIndex) {
  const t = tiles[tileIndex];
  
  // Floods DESTROY ALL bricks!
  if (t.bricks > 0) {
    const lost = t.bricks;
    t.bricks = 0;
    log(`üåä FLOOD destroys ALL ${lost} bricks on ${t.label}! üíî`);
  } else if (t.state === "dry") {
    t.state = "flooded";
    log(`üåä Flood hits ${t.label} - now FLOODED!`);
  } else if (t.state === "flooded") {
    t.state = "sunk";
    t.owner = null;
    log(`üíÄ Flood sinks ${t.label}! It's destroyed forever.`);
  }
  
  // Sync to Firebase
  if (isOnlineMode) pushGameState('flood');
  
  closeModal();
  finishTurnAfterCrisis();
}

function finishTurnAfterCrisis() {
  // Continue with rent check (rent = $1 base + $1 per 4 bricks)
  const p = players[current];
  const t = tiles[p.pos];
  if (t.owner !== null && t.owner !== current && t.state === "dry") {
    const wallBonus = Math.floor(t.bricks / 4);
    const rent = 1 + wallBonus;
    p.money = Math.max(0, p.money - rent);
    players[t.owner].money += rent;
    if (wallBonus > 0) {
      log(`üí∏ ${p.name} pays $${rent} rent to ${players[t.owner].name} (base $1 + ${wallBonus} wall bonus)`);
    } else {
      log(`üí∏ ${p.name} pays $1 rent to ${players[t.owner].name}`);
    }
  }
  
  render();
}

function closeModal() {
  document.getElementById("modal").classList.remove("active");
}

// Tile Info descriptions by type
const tileInfoRules = {
  en: {
    start: [
      "All players begin here",
      "Pass or land here = Earn $2",
      "Safe from all flood effects"
    ],
    property: [
      "Buy for $2 to own it",
      "Rent: $1 (dry) or $0 (flooded)",
      "+$1 rent per 4 bricks (protected)",
      "Build bricks to protect from floods"
    ],
    policy: [
      "Cannot be bought - public building",
      "Town Hall: Free +1 brick",
      "Workshop: Earn +$1",
      "Depot: Repair a flooded tile (+1 brick)",
      "Can be protected with bricks"
    ],
    storm: [
      "Pick ANY tile on the board",
      "Remove 2 bricks from that tile",
      "No bricks? Dry becomes Flooded",
      "If 20+ total bricks: Storm BLOCKED!"
    ],
    flood: [
      "Pick ANY tile on the board",
      "Remove ALL bricks from that tile",
      "Or: Flooded tile becomes SUNK",
      "If 30+ total bricks: Only -2 bricks"
    ]
  },
  fr: {
    start: [
      "Tous les joueurs commencent ici",
      "Passer ou atterrir = Gagner 2‚Ç¨",
      "Prot√©g√© contre les inondations"
    ],
    property: [
      "Acheter pour 2‚Ç¨",
      "Loyer: 1‚Ç¨ (sec) ou 0‚Ç¨ (inond√©)",
      "+1‚Ç¨ loyer par 4 briques (prot√©g√©)",
      "Construire des briques pour prot√©ger"
    ],
    policy: [
      "Ne peut pas √™tre achet√© - b√¢timent public",
      "Mairie: +1 brique gratuite",
      "Atelier: Gagner +1‚Ç¨",
      "D√©p√¥t: R√©parer une case inond√©e (+1 brique)",
      "Peut √™tre prot√©g√© avec des briques"
    ],
    storm: [
      "Choisir N'IMPORTE quelle case",
      "Retirer 2 briques de cette case",
      "Pas de briques? Sec devient Inond√©",
      "Si 20+ briques: Temp√™te BLOQU√âE!"
    ],
    flood: [
      "Choisir N'IMPORTE quelle case",
      "Retirer TOUTES les briques",
      "Ou: Case inond√©e devient COUL√âE",
      "Si 30+ briques: Seulement -2 briques"
    ]
  }
};

function showTileInfo(index) {
  const tile = tiles[index];
  const modal = document.getElementById("tile-info-modal");
  const icon = document.getElementById("tile-info-icon");
  const name = document.getElementById("tile-info-name");
  const badge = document.getElementById("tile-info-badge");
  const rulesList = document.getElementById("tile-info-rules-list");
  const rulesTitle = document.getElementById("tile-info-rules-title");
  
  // Set icon
  icon.innerHTML = tile.icon;
  icon.className = `tile-info-icon ${tile.type}`;
  
  // Set name and badge
  name.textContent = tile.label;
  badge.textContent = tile.type.charAt(0).toUpperCase() + tile.type.slice(1);
  badge.className = `tile-type-badge ${tile.type}`;
  
  // Set rules
  rulesTitle.textContent = currentLang === 'en' ? 'How it works:' : 'Comment √ßa marche:';
  const rules = tileInfoRules[currentLang][tile.type] || [];
  rulesList.innerHTML = rules.map(rule => `<li>${rule}</li>`).join('');
  
  // Add current tile status if property or policy
  if (tile.type === 'property' || tile.type === 'policy') {
    let status = [];
    if (tile.owner !== null) {
      status.push(`<li style="color: ${players[tile.owner].color}">${currentLang === 'en' ? 'Owner' : 'Propri√©taire'}: ${players[tile.owner].name}</li>`);
    }
    if (tile.bricks > 0) {
      status.push(`<li>üß± ${tile.bricks} ${currentLang === 'en' ? 'bricks' : 'briques'} ${tile.bricks >= 4 ? '(üõ°Ô∏è Protected)' : ''}</li>`);
    }
    if (tile.state !== 'dry') {
      status.push(`<li>${tile.state === 'flooded' ? 'üíß Flooded' : 'üíÄ Sunk'}</li>`);
    }
    if (status.length > 0) {
      rulesList.innerHTML += `<li style="border-top: 1px solid rgba(255,255,255,0.2); margin-top: 8px; padding-top: 8px;"><b>${currentLang === 'en' ? 'Current Status' : '√âtat actuel'}:</b></li>` + status.join('');
    }
  }
  
  modal.classList.add("active");
}

function closeTileInfo() {
  document.getElementById("tile-info-modal").classList.remove("active");
}

function endTurn() {
  // In online mode, only allow if it's my turn
  if (isOnlineMode) {
    if (myPlayerIndex !== current) {
      console.log('Not my turn to end. myPlayerIndex:', myPlayerIndex, 'current:', current);
      return;
    }
    doEndTurn();
  } else {
    doEndTurn();
  }
}

function doEndTurn() {
  rolled = false;
  current = (current + 1) % players.length;
  
  // New round when back to player 1
  if (current === 0) {
    round++;
    log(`<br>‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ROUND ${round} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
    
    // Income phase
    players.forEach((p, i) => {
      let income = 1; // Base income
      tiles.forEach(t => {
        if (t.owner === i && t.state === "dry") income++;
      });
      p.money += income;
      log(`üí∞ ${p.name} earns $${income} income`);
    });
  }
  
  // Check win condition - last player with money or properties wins
  checkWinCondition();
  
  // Sync to Firebase
  if (isOnlineMode) {
    pushGameState('endTurn');
    updateTurnIndicator();
  }
  
  render();
  
  // Auto-roll for next player after a short delay
  setTimeout(() => {
    if (gameStarted && !checkGameOver()) {
      autoRoll();
    }
  }, 500);
}

function getClimateStability() {
  // Total bricks across all tiles
  return tiles.reduce((sum, t) => sum + t.bricks, 0);
}

function getSunkCount() {
  return tiles.filter(t => t.state === "sunk").length;
}

function updateClimateDisplay() {
  const climate = getClimateStability();
  const fill = document.getElementById("climate-fill");
  const status = document.getElementById("climate-status");
  const value = document.getElementById("climate-value");
  
  value.textContent = climate;
  fill.style.width = `${Math.min(100, climate * 2.5)}%`; // 40 = 100%
  
  if (climate >= 40) {
    fill.style.background = "linear-gradient(90deg, #4caf50, #00e676)";
    status.textContent = "üåü " + t('climateVictory');
    status.className = "climate-status stable";
  } else if (climate >= 30) {
    fill.style.background = "linear-gradient(90deg, #4caf50, #8bc34a)";
    status.textContent = "üåä " + t('climateFloodsWeak').replace('{n}', 40 - climate);
    status.className = "climate-status stable";
  } else if (climate >= 20) {
    fill.style.background = "linear-gradient(90deg, #8bc34a, #cddc39)";
    status.textContent = "üõ°Ô∏è " + t('climateStormsBlocked').replace('{n}', 40 - climate);
    status.className = "climate-status stable";
  } else if (climate >= 8) {
    fill.style.background = "linear-gradient(90deg, #ffeb3b, #ff9800)";
    status.textContent = "‚õàÔ∏è " + t('climateStormsWeak').replace('{n}', 20 - climate);
    status.className = "climate-status warning";
  } else {
    fill.style.background = "linear-gradient(90deg, #f44336, #b71c1c)";
    status.textContent = "üí• " + t('climateCritical').replace('{n}', 8 - climate);
    status.className = "climate-status danger";
  }
}

function checkGameOver() {
  // Collective win - climate stabilized!
  if (getClimateStability() >= 40) return true;
  
  // All players bankrupt = game over
  const alivePlayers = players.filter((p, i) => {
    const ownsDryProperty = tiles.some(t => t.owner === i && t.state === "dry");
    return p.money > 0 || ownsDryProperty;
  });
  return alivePlayers.length <= 1;
}

function checkWinCondition() {
  const climate = getClimateStability();
  const sunkCount = getSunkCount();
  
  // COLLECTIVE WIN - Climate fully stabilized!
  if (climate >= 40) {
    log(`<br>üåüüåçüåü COLLECTIVE VICTORY! üåüüåçüåü`);
    log(`With ${climate} bricks, the climate is FULLY STABILIZED!`);
    showVictoryModal('collective', null, climate, sunkCount);
    endGame();
    return;
  }
  
  // Check if all tiles are sunk (catastrophe) - with 7 properties, 5 sunk is catastrophic
  if (sunkCount >= 5) {
    log(`<br>üí•üåä CATASTROPHE! ${sunkCount} tiles have sunk!`);
    showVictoryModal('catastrophe', null, climate, sunkCount);
    endGame();
    return;
  }
  
  // Check if only one player remains
  const alivePlayers = players.filter((p, i) => {
    const ownsDryProperty = tiles.some(t => t.owner === i && t.state === "dry");
    return p.money > 0 || ownsDryProperty;
  });
  
  if (alivePlayers.length === 1) {
    const winner = alivePlayers[0];
    log(`<br>üèÜ ${winner.name} is the last one standing with $${winner.money}!`);
    showVictoryModal('individual', winner, climate, sunkCount);
    endGame();
  } else if (alivePlayers.length === 0) {
    log(`<br>üí• Everyone is bankrupt! The climate wins.`);
    showVictoryModal('catastrophe', null, climate, sunkCount);
    endGame();
  }
}

function endGame() {
  document.getElementById("buyBtn").disabled = true;
  document.getElementById("contributeBtn").disabled = true;
  document.getElementById("buildBtn").disabled = true;
  document.getElementById("endBtn").disabled = true;
  gameStarted = false;
}

function showVictoryModal(type, winner, climate, sunkCount) {
  const modal = document.getElementById("victory-modal");
  const content = document.getElementById("victory-content");
  const icon = document.getElementById("victory-icon");
  const title = document.getElementById("victory-title");
  const message = document.getElementById("victory-message");
  const playersDiv = document.getElementById("victory-players");
  const stats = document.getElementById("victory-stats");
  
  content.className = `modal victory-modal ${type}`;
  
  const bricksWord = t('bricks');
  
  if (type === 'collective') {
    icon.textContent = 'üåç';
    title.textContent = t('collectiveVictory');
    message.innerHTML = currentLang === 'fr' 
      ? `Avec <strong>${climate} briques</strong>, le climat est STABILIS√â!<br>Les temp√™tes et inondations ne menacent plus la c√¥te.`
      : `With <strong>${climate} bricks</strong>, the climate is FULLY STABILIZED!<br>Storms and floods no longer threaten the coast.`;
    playersDiv.innerHTML = players.map(p => 
      `<div class="victory-player" style="background: ${p.color}; color: white;">
        üèÜ ${p.name} - $${p.money}
      </div>`
    ).join('');
    stats.innerHTML = `
      <div>üåç Total: <strong>${climate} ${bricksWord}</strong></div>
      <div>üìÖ ${t('roundsPlayed')}: <strong>${round}</strong></div>
      <div>üéâ ${t('allWin')}</div>
    `;
  } else if (type === 'individual') {
    icon.textContent = 'üëë';
    title.textContent = t('winner');
    message.innerHTML = currentLang === 'fr'
      ? `<strong>${winner.name}</strong> est le dernier debout!`
      : `<strong>${winner.name}</strong> is the last one standing!`;
    playersDiv.innerHTML = `
      <div class="victory-player" style="background: ${winner.color}; color: white; font-size: 1.2rem; padding: 12px 25px;">
        üëë ${winner.name} - $${winner.money}
      </div>
    `;
    const climateMsg = climate >= 20 ? `üåç ${t('climateStable')} (${climate} ${bricksWord})` : 
                       climate < 8 ? `‚ö†Ô∏è ${t('climateInDanger')} (${climate} ${bricksWord})` : 
                       `üåç ${t('climate')}: ${climate} ${bricksWord}`;
    stats.innerHTML = `
      <div>${climateMsg}</div>
      <div>üìÖ ${t('roundsPlayed')}: <strong>${round}</strong></div>
      <div>üíÄ ${t('tilesSunk')}: <strong>${sunkCount}</strong></div>
    `;
  } else { // catastrophe
    icon.textContent = 'üíÄ';
    title.textContent = t('gameOver');
    message.innerHTML = sunkCount >= 5 
      ? (currentLang === 'fr' 
        ? `<strong>${sunkCount} cases</strong> ont coul√©!<br>La c√¥te est d√©truite. Tout le monde perd.`
        : `<strong>${sunkCount} tiles</strong> have sunk!<br>The coast is destroyed. Everyone loses.`)
      : (currentLang === 'fr'
        ? `Tout le monde est en faillite!<br>Le climat gagne cette manche.`
        : `Everyone is bankrupt!<br>The climate wins this round.`);
    playersDiv.innerHTML = players.map(p => 
      `<div class="victory-player" style="background: rgba(255,255,255,0.1); color: #999;">
        üíÄ ${p.name} - $${p.money}
      </div>`
    ).join('');
    stats.innerHTML = `
      <div>üåç ${t('climate')}: <strong>${climate} ${bricksWord}</strong></div>
      <div>üìÖ ${t('roundsPlayed')}: <strong>${round}</strong></div>
      <div>üíÄ ${t('tilesSunk')}: <strong>${sunkCount}</strong></div>
    `;
  }
  
  setTimeout(() => {
    modal.classList.add("active");
  }, 500);
}

function restartGame() {
  // Hide victory modal
  document.getElementById("victory-modal").classList.remove("active");
  
  // Reset players
  players.forEach((p, i) => {
    p.money = 5;
    p.pos = 0;
  });
  
  // Reset tiles
  tiles.forEach(t => {
    t.owner = null;
    t.state = "dry";
    t.bricks = 0;
  });
  
  // Reset game state
  current = 0;
  rolled = false;
  round = 1;
  gameStarted = false;
  
  // Clear log
  document.getElementById("log").innerHTML = '';
  
  // Leave online room if any
  if (isOnlineMode && roomRef) {
    leaveRoom();
  }
  
  // Show lobby modal
  document.getElementById("lobby-modal").classList.add("active");
  showLobbyMenu();
  initSetup();
}

// Setup screen
function initSetup() {
  const setupDiv = document.getElementById("player-setup");
  const playerWord = t('player');
  setupDiv.innerHTML = players.map((p, i) => `
    <div class="player-setup-row">
      <div class="player-setup-top">
        <div class="player-emoji-display" onclick="openEmojiPicker(${i}, event)">${p.emoji}</div>
        <input type="text" class="player-name-input" id="name-${i}" value="${p.name}" placeholder="${playerWord} ${i+1}">
        <button class="random-btn" onclick="randomizePlayer(${i})" title="Random">üé≤</button>
      </div>
      <div class="color-picker">
        ${COLOR_OPTIONS.map(c => `
          <div class="color-option ${p.color === c.value ? 'selected' : ''}" 
               style="background: ${c.value}" 
               onclick="selectColor(${i}, '${c.value}')" 
               data-player="${i}" data-color="${c.value}"></div>
        `).join('')}
      </div>
    </div>
  `).join('');
}

function selectColor(playerIndex, color) {
  players[playerIndex].color = color;
  initSetup(); // Refresh to show selection
}

function selectEmoji(playerIndex, emoji) {
  players[playerIndex].emoji = emoji;
  closeEmojiPicker();
  initSetup();
}

function openEmojiPicker(playerIndex, event) {
  if (event) event.stopPropagation();
  const modal = document.getElementById('emoji-picker-modal');
  const grid = document.getElementById('emoji-picker-grid');
  grid.innerHTML = EMOJI_OPTIONS.map(e => `
    <div class="emoji-option ${players[playerIndex].emoji === e ? 'selected' : ''}" 
         onclick="selectEmoji(${playerIndex}, '${e}')">${e}</div>
  `).join('');
  modal.classList.add('active');
}

function closeEmojiPicker() {
  document.getElementById('emoji-picker-modal').classList.remove('active');
}

function randomizePlayer(playerIndex) {
  players[playerIndex].color = COLOR_OPTIONS[Math.floor(Math.random() * COLOR_OPTIONS.length)].value;
  players[playerIndex].emoji = EMOJI_OPTIONS[Math.floor(Math.random() * EMOJI_OPTIONS.length)];
  initSetup();
}

function startGame() {
  // Update player names
  players.forEach((p, i) => {
    const nameInput = document.getElementById(`name-${i}`);
    if (nameInput.value.trim()) {
      p.name = nameInput.value.trim();
    }
  });
  
  // Hide setup modal
  document.getElementById("setup-modal").classList.remove("active");
  gameStarted = true;
  
  // Start game
  render();
  log("üéÆ Game started!");
  log("üèÜ Build 40 bricks together = EVERYONE WINS!");
  log("‚õàÔ∏è Storm: -2 bricks | üåä Flood: ALL bricks gone");
  log("üåç Climate 20+: storms blocked | 30+: floods weakened");
  
  // Auto-roll for first player
  setTimeout(() => autoRoll(), 800);
}

// Initialize setup
initSetup();
renderRules();
render();

// Hide setup modal initially (lobby shows first)
document.getElementById("setup-modal").classList.remove("active");
</script>

</body>
</html>


